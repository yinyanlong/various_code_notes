# Copyright (c) 2015, Remzi Arpaci-Dusseau
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
# 
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# 
# * Neither the name of zplot nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


#
# PLEASE READ
#
# If you are going to edit zplot, you should read this comment.
#
# Zplot uses a simple script, make-docs.py, to auto-generate documentation
# from this file. Thus, you need to follow its style if you want make-docs
# to keep working.
#
# The markup is simple to follow. Basically, for an important class,
# mark it with a header that says in the comment before the class:
#
# --class-- class_name
#
# (description of class)
# 
# Then, to keep the parsing of the doc generator simple, puts arguments
# of each method on a separate line, with a comment that precedes it, e.g.:
#
# def fub(self,
#         # bar is used to pass in the number of bars
#         bar = 10,
#
#         # foo is used for the number of foos
#         foo = 1,
#        ):
#
# This auto-generates the docs in a way that is easy to read.
#
# Thanks!
# The Zplot Team
#

import time
import math
import os
import stat
import sys
import sqlite3
import re
import socket
import random
import types
import string

#
# UTILITY function(s)
#
def abort(str):
    print('Abort! Reason: (%s)' % str)
    exit(1)

#
# --class-- color IGNORE
#
# Separate class just to map color names to RGB values.
# Not of general use.
#
class color:
    def __init__(self,
                 ):
        self.color_list = {
            'aliceblue'              :  '0.94 0.97 1.00',
            'antiquewhite'           :  '0.98 0.92 0.84',
            'aqua'                   :  '0.00 1.00 1.00',
            'aquamarine'             :  '0.50 1.00 0.83',
            'azure'                  :  '0.94 1.00 1.00',
            'beige'                  :  '0.96 0.96 0.86',
            'bisque'                 :  '1.00 0.89 0.77',
            'black'                  :  '0.00 0.00 0.00',
            'blanchedalmond'         :  '1.00 0.92 0.80',
            'blue'                   :  '0.00 0.00 1.00',
            'blueviolet'             :  '0.54 0.17 0.89',
            'brown'                  :  '0.65 0.16 0.16',
            'burlywood'              :  '0.87 0.72 0.53',
            'cadetblue'              :  '0.37 0.62 0.63',
            'chartreuse'             :  '0.50 1.00 0.00',
            'chocolate'              :  '0.82 0.41 0.12',
            'coral'                  :  '1.00 0.50 0.31',
            'cornflowerblue'         :  '0.39 0.58 0.93',
            'cornsilk'               :  '1.00 0.97 0.86',
            'crimson'                :  '0.86 0.08 0.24',
            'cyan'                   :  '0.00 1.00 1.00',
            'darkblue'               :  '0.00 0.00 0.55',
            'darkcyan'               :  '0.00 0.55 0.55',
            'darkgoldenrod'          :  '0.72 0.53 0.04',
            'darkgray'               :  '0.66 0.66 0.66',
            'darkgreen'              :  '0.00 0.39 0.00',
            'darkkhaki'              :  '0.74 0.72 0.42',
            'darkmagenta'            :  '0.55 0.00 0.55',
            'darkolivegreen'         :  '0.33 0.42 0.18',
            'darkorange'             :  '1.00 0.55 0.00',
            'darkorchid'             :  '0.60 0.20 0.80',
            'darkred'                :  '0.55 0.00 0.00',
            'darksalmon'             :  '0.91 0.59 0.48',
            'darkseagreen'           :  '0.55 0.74 0.56',
            'darkslateblue'          :  '0.28 0.24 0.55',
            'darkslategray'          :  '0.18 0.31 0.31',
            'darkturquoise'          :  '0.00 0.87 0.82',
            'darkviolet'             :  '0.58 0.00 0.83',
            'deeppink'               :  '1.00 0.08 0.58',
            'deepskyblue'            :  '0.00 0.75 1.00',
            'dimgray'                :  '0.41 0.41 0.41',
            'dodgerblue'             :  '0.12 0.56 1.00',
            'drabgreen'              :  '0.60 0.80 0.60',
            'dullyellow'             :  '1.00 0.90 0.60',
            'firebrick'              :  '0.70 0.13 0.13',
            'floralwhite'            :  '1.00 0.98 0.94',
            'forestgreen'            :  '0.13 0.55 0.13',
            'fuchsia'                :  '1.00 0.00 1.00',
            'gainsboro'              :  '0.86 0.86 0.86',
            'ghostwhite'             :  '0.97 0.97 1.00',
            'gold'                   :  '1.00 0.84 0.00',
            'goldenrod'              :  '0.85 0.65 0.13',
            'gray'                   :  '0.50 0.50 0.50',
            'green'                  :  '0.00 0.50 0.00',
            'greenyellow'            :  '0.68 1.00 0.18',
            'honeydew'               :  '0.94 1.00 0.94',
            'hotpink'                :  '1.00 0.41 0.71',
            'indianred'              :  '0.80 0.36 0.36',
            'indigo'                 :  '0.29 0.00 0.51',
            'ivory'                  :  '1.00 1.00 0.94',
            'khaki'                  :  '0.94 0.90 0.55',
            'lavender'               :  '0.90 0.90 0.98',
            'lavenderblush'          :  '1.00 0.94 0.96',
            'lawngreen'              :  '0.49 0.99 0.00',
            'lemonchiffon'           :  '1.00 0.98 0.80',
            'lightblue'              :  '0.68 0.85 0.90',
            'lightcoral'             :  '0.94 0.50 0.50',
            'lightcyan'              :  '0.88 1.00 1.00',
            'lightgoldenrodyellow'   :  '0.98 0.98 0.82',
            'lightgreen'             :  '0.56 0.93 0.56',
            'lightgrey'              :  '0.83 0.83 0.83',
            'lightpink'              :  '1.00 0.71 0.76',
            'lightsalmon'            :  '1.00 0.63 0.48',
            'lightseagreen'          :  '0.13 0.70 0.67',
            'lightskyblue'           :  '0.53 0.81 0.98',
            'lightslategray'         :  '0.47 0.53 0.60',
            'lightsteelblue'         :  '0.69 0.77 0.87',
            'lightyellow'            :  '1.00 1.00 0.88',
            'lime'                   :  '0.00 1.00 0.00',
            'limegreen'              :  '0.20 0.80 0.20',
            'linen'                  :  '0.98 0.94 0.90',
            'magenta'                :  '1.00 0.00 1.00',
            'maroon'                 :  '0.50 0.00 0.00',
            'mediumaquamarine'       :  '0.40 0.80 0.67',
            'mediumblue'             :  '0.00 0.00 0.80',
            'mediumorchid'           :  '0.73 0.33 0.83',
            'mediumpurple'           :  '0.58 0.44 0.86',
            'mediumseagreen'         :  '0.24 0.70 0.44',
            'mediumslateblue'        :  '0.48 0.41 0.93',
            'mediumspringgreen'      :  '0.00 0.98 0.60',
            'mediumturquoise'        :  '0.28 0.82 0.80',
            'mediumvioletred'        :  '0.78 0.08 0.52',
            'midnightblue'           :  '0.10 0.10 0.44',
            'mintcream'              :  '0.96 1.00 0.98',
            'mistyrose'              :  '1.00 0.89 0.88',
            'moccasin'               :  '1.00 0.89 0.71',
            'navajowhite'            :  '1.00 0.87 0.68',
            'navy'                   :  '0.00 0.00 0.50',
            'oldlace'                :  '0.99 0.96 0.90',
            'olivedrab'              :  '0.42 0.56 0.14',
            'orange'                 :  '1.00 0.65 0.00',
            'orangered'              :  '1.00 0.27 0.00',
            'orchid'                 :  '0.85 0.44 0.84',
            'palegoldenrod'          :  '0.93 0.91 0.67',
            'palegreen'              :  '0.60 0.98 0.60',
            'paleturquoise'          :  '0.69 0.93 0.93',
            'palevioletred'          :  '0.86 0.44 0.58',
            'papayawhip'             :  '1.00 0.94 0.84',
            'peachpuff'              :  '1.00 0.85 0.73',
            'peru'                   :  '0.80 0.52 0.25',
            'pink'                   :  '1.00 0.78 0.80',
            'plum'                   :  '0.87 0.63 0.87',
            'powderblue'             :  '0.69 0.88 0.90',
            'purple'                 :  '0.50 0.00 0.50',
            'red'                    :  '1.00 0.00 0.00',
            'rosybrown'              :  '0.74 0.56 0.56',
            'royalblue'              :  '0.25 0.41 0.88',
            'saddlebrown'            :  '0.55 0.27 0.07',
            'salmon'                 :  '0.98 0.50 0.45',
            'sandybrown'             :  '0.96 0.64 0.38',
            'seagreen'               :  '0.18 0.55 0.34',
            'seashell'               :  '1.00 0.96 0.93',
            'sienna'                 :  '0.63 0.32 0.18',
            'silver'                 :  '0.75 0.75 0.75',
            'skyblue'                :  '0.53 0.81 0.92',
            'slateblue'              :  '0.42 0.35 0.80',
            'snow'                   :  '1.00 0.98 0.98',
            'springgreen'            :  '0.00 1.00 0.50',
            'steelblue'              :  '0.27 0.51 0.71',
            'tan'                    :  '0.82 0.71 0.55',
            'teal'                   :  '0.00 0.50 0.50',
            'thistle'                :  '0.85 0.75 0.85',
            'tomato'                 :  '1.00 0.39 0.28',
            'turquoise'              :  '0.25 0.88 0.82',
            'violet'                 :  '0.93 0.51 0.93',
            'wheat'                  :  '0.96 0.87 0.70',
            'white'                  :  '1.00 1.00 1.00',
            'whitesmoke'             :  '0.96 0.96 0.96',
            'yellow'                 :  '1.00 1.00 0.00',
            'yellowgreen'            :  '0.60 0.80 0.20',
        }
        return

    # converts floating point value (from 0->1) to
    # proper RGB hex value (from 0x00 to 0xFF)
    def __float_to_rgb(self, value):
        outValue = int(float(value) * 255.0)
        if outValue < 16:
            return '0%x' % outValue
        else:
            return '%x' % outValue

    # Get the color as three values "R G B"
    def get(self, color):
        if color not in self.color_list:
            print('color [%s] not valid; returning 0 0 0' % color)
            return '0 0 0'
        return self.color_list[color]

    # Get color as hex value of form "#RRGGBB"
    def get_as_hex(self, color):
        if color[0] == '#':
            # assume this is hex value already; just return it
            return color
        tmp = color.split(',')
        if len(tmp) == 3:
            # this is just three rgb values, comma-separated
            r, g, b = tmp[0], tmp[1], tmp[2]
        else:
            # assume that it is a color name
            if color not in self.color_list:
                print('color [%s] not valid; returning 0 0 0' % color)
                r, g, b = 0.0, 0.0, 0.0
            else:
                r, g, b = self.color_list[color].split()
        return '#%s%s%s' % (self.__float_to_rgb(r),
                            self.__float_to_rgb(g),
                            self.__float_to_rgb(b))
# END: class color

# 
# --class-- fontsize IGNORE
#
# A simple class to get font size information. The data is stripped
# from a bunch of .afm files found on the "internet".
#
class fontsize:
    def __init__(self,
                 ):
        self.font_width = {}
        self.font_width['Courier-Bold'] = {' ':600, '!':600, '"':600, '#':600, 
                                           '$':600, '%':600, '&':600, "'":600, 
                                           '(':600, ')':600, '*':600, '+':600, 
                                           ',':600, '-':600, '.':600, '/':600, 
                                           '0':600, '1':600, '2':600, '3':600, 
                                           '4':600, '5':600, '6':600, '7':600, 
                                           '8':600, '9':600, ':':600, ';':600, 
                                           '<':600, '=':600, '>':600, '?':600, 
                                           '@':600, 'A':600, 'B':600, 'C':600, 
                                           'D':600, 'E':600, 'F':600, 'G':600, 
                                           'H':600, 'I':600, 'J':600, 'K':600, 
                                           'L':600, 'M':600, 'N':600, 'O':600, 
                                           'P':600, 'Q':600, 'R':600, 'S':600, 
                                           'T':600, 'U':600, 'V':600, 'W':600, 
                                           'X':600, 'Y':600, 'Z':600, '[':600, 
                                           '\\':600, ']':600, '^':600, '_':600, 
                                           '`':600, 'a':600, 'b':600, 'c':600, 
                                           'd':600, 'e':600, 'f':600, 'g':600, 
                                           'h':600, 'i':600, 'j':600, 'k':600, 
                                           'l':600, 'm':600, 'n':600, 'o':600, 
                                           'p':600, 'q':600, 'r':600, 's':600, 
                                           't':600, 'u':600, 'v':600, 'w':600, 
                                           'x':600, 'y':600, 'z':600, '{':600, 
                                           '|':600, '}':600, '~':600}
        self.font_width['Courier-BoldOblique'] = {' ':600, '!':600, '"':600, 
                                                  '#':600, '$':600, '%':600, 
                                                  '&':600, "'":600, '(':600, 
                                                  ')':600, '*':600, '+':600, 
                                                  ',':600, '-':600, '.':600, 
                                                  '/':600, '0':600, '1':600, 
                                                  '2':600, '3':600, '4':600, 
                                                  '5':600, '6':600, '7':600, 
                                                  '8':600, '9':600, ':':600, 
                                                  ';':600, '<':600, '=':600, 
                                                  '>':600, '?':600, '@':600, 
                                                  'A':600, 'B':600, 'C':600, 
                                                  'D':600, 'E':600, 'F':600, 
                                                  'G':600, 'H':600, 'I':600, 
                                                  'J':600, 'K':600, 'L':600, 
                                                  'M':600, 'N':600, 'O':600, 
                                                  'P':600, 'Q':600, 'R':600, 
                                                  'S':600, 'T':600, 'U':600, 
                                                  'V':600, 'W':600, 'X':600, 
                                                  'Y':600, 'Z':600, '[':600, 
                                                  '\\':600, ']':600, '^':600, 
                                                  '_':600, '`':600, 'a':600, 
                                                  'b':600, 'c':600, 'd':600, 
                                                  'e':600, 'f':600, 'g':600, 
                                                  'h':600, 'i':600, 'j':600, 
                                                  'k':600, 'l':600, 'm':600, 
                                                  'n':600, 'o':600, 'p':600, 
                                                  'q':600, 'r':600, 's':600, 
                                                  't':600, 'u':600, 'v':600, 
                                                  'w':600, 'x':600, 'y':600, 
                                                  'z':600, '{':600, '|':600, 
                                                  '}':600, '~':600}
        self.font_width['Courier-Oblique'] = {' ':600, '!':600, '"':600, '#':600, 
                                              '$':600, '%':600, '&':600, "'":600, 
                                              '(':600, ')':600, '*':600, '+':600, 
                                              ',':600, '-':600, '.':600, '/':600, 
                                              '0':600, '1':600, '2':600, '3':600, 
                                              '4':600, '5':600, '6':600, '7':600, 
                                              '8':600, '9':600, ':':600, ';':600, 
                                              '<':600, '=':600, '>':600, '?':600, 
                                              '@':600, 'A':600, 'B':600, 'C':600, 
                                              'D':600, 'E':600, 'F':600, 'G':600, 
                                              'H':600, 'I':600, 'J':600, 'K':600, 
                                              'L':600, 'M':600, 'N':600, 'O':600, 
                                              'P':600, 'Q':600, 'R':600, 'S':600, 
                                              'T':600, 'U':600, 'V':600, 'W':600, 
                                              'X':600, 'Y':600, 'Z':600, '[':600, 
                                              '\\':600, ']':600, '^':600, '_':600, 
                                              '`':600, 'a':600, 'b':600, 'c':600, 
                                              'd':600, 'e':600, 'f':600, 'g':600, 
                                              'h':600, 'i':600, 'j':600, 'k':600, 
                                              'l':600, 'm':600, 'n':600, 'o':600, 
                                              'p':600, 'q':600, 'r':600, 's':600, 
                                              't':600, 'u':600, 'v':600, 'w':600, 
                                              'x':600, 'y':600, 'z':600, '{':600, 
                                              '|':600, '}':600, '~':600}
        self.font_width['Courier'] = {' ':600, '!':600, '"':600, '#':600, '$':600, 
                                      '%':600, '&':600, "'":600, '(':600, ')':600, 
                                      '*':600, '+':600, ',':600, '-':600, '.':600, 
                                      '/':600, '0':600, '1':600, '2':600, '3':600, 
                                      '4':600, '5':600, '6':600, '7':600, '8':600, 
                                      '9':600, ':':600, ';':600, '<':600, '=':600, 
                                      '>':600, '?':600, '@':600, 'A':600, 'B':600, 
                                      'C':600, 'D':600, 'E':600, 'F':600, 'G':600, 
                                      'H':600, 'I':600, 'J':600, 'K':600, 'L':600, 
                                      'M':600, 'N':600, 'O':600, 'P':600, 'Q':600, 
                                      'R':600, 'S':600, 'T':600, 'U':600, 'V':600, 
                                      'W':600, 'X':600, 'Y':600, 'Z':600, '[':600, 
                                      '\\':600, ']':600, '^':600, '_':600, 
                                      '`':600, 'a':600, 'b':600, 'c':600, 'd':600, 
                                      'e':600, 'f':600, 'g':600, 'h':600, 'i':600, 
                                      'j':600, 'k':600, 'l':600, 'm':600, 'n':600, 
                                      'o':600, 'p':600, 'q':600, 'r':600, 's':600, 
                                      't':600, 'u':600, 'v':600, 'w':600, 'x':600, 
                                      'y':600, 'z':600, '{':600, '|':600, '}':600, 
                                      '~':600}
        self.font_width['Helvetica-Bold'] = {' ':278, '!':333, '"':474, '#':556, 
                                             '$':556, '%':889, '&':722, "'":278, 
                                             '(':333, ')':333, '*':389, '+':584, 
                                             ',':278, '-':333, '.':278, '/':278, 
                                             '0':556, '1':556, '2':556, '3':556, 
                                             '4':556, '5':556, '6':556, '7':556, 
                                             '8':556, '9':556, ':':333, ';':333, 
                                             '<':584, '=':584, '>':584, '?':611, 
                                             '@':975, 'A':722, 'B':722, 'C':722, 
                                             'D':722, 'E':667, 'F':611, 'G':778, 
                                             'H':722, 'I':278, 'J':556, 'K':722, 
                                             'L':611, 'M':833, 'N':722, 'O':778, 
                                             'P':667, 'Q':778, 'R':722, 'S':667, 
                                             'T':611, 'U':722, 'V':667, 'W':944, 
                                             'X':667, 'Y':667, 'Z':611, '[':333, 
                                             '\\':278, ']':333, '^':584, '_':556, 
                                             '`':278, 'a':556, 'b':611, 'c':556, 
                                             'd':611, 'e':556, 'f':333, 'g':611, 
                                             'h':611, 'i':278, 'j':278, 'k':556, 
                                             'l':278, 'm':889, 'n':611, 'o':611, 
                                             'p':611, 'q':611, 'r':389, 's':556, 
                                             't':333, 'u':611, 'v':556, 'w':778, 
                                             'x':556, 'y':556, 'z':500, '{':389, 
                                             '|':280, '}':389, '~':584}
        self.font_width['Helvetica-BoldOblique'] = {' ':278, '!':333, '"':474, 
                                                    '#':556, '$':556, '%':889, 
                                                    '&':722, "'":278, '(':333, 
                                                    ')':333, '*':389, '+':584, 
                                                    ',':278, '-':333, '.':278, 
                                                    '/':278, '0':556, '1':556, 
                                                    '2':556, '3':556, '4':556, 
                                                    '5':556, '6':556, '7':556, 
                                                    '8':556, '9':556, ':':333, 
                                                    ';':333, '<':584, '=':584, 
                                                    '>':584, '?':611, '@':975, 
                                                    'A':722, 'B':722, 'C':722, 
                                                    'D':722, 'E':667, 'F':611, 
                                                    'G':778, 'H':722, 'I':278, 
                                                    'J':556, 'K':722, 'L':611, 
                                                    'M':833, 'N':722, 'O':778, 
                                                    'P':667, 'Q':778, 'R':722, 
                                                    'S':667, 'T':611, 'U':722, 
                                                    'V':667, 'W':944, 'X':667, 
                                                    'Y':667, 'Z':611, '[':333, 
                                                    '\\':278, ']':333, '^':584, 
                                                    '_':556, '`':278, 'a':556, 
                                                    'b':611, 'c':556, 'd':611, 
                                                    'e':556, 'f':333, 'g':611, 
                                                    'h':611, 'i':278, 'j':278, 
                                                    'k':556, 'l':278, 'm':889, 
                                                    'n':611, 'o':611, 'p':611, 
                                                    'q':611, 'r':389, 's':556, 
                                                    't':333, 'u':611, 'v':556, 
                                                    'w':778, 'x':556, 'y':556, 
                                                    'z':500, '{':389, '|':280, 
                                                    '}':389, '~':584}
        self.font_width['Helvetica-Oblique'] = {' ':278, '!':278, '"':355, 
                                                '#':556, '$':556, '%':889, 
                                                '&':667, "'":222, '(':333, 
                                                ')':333, '*':389, '+':584, 
                                                ',':278, '-':333, '.':278, 
                                                '/':278, '0':556, '1':556, 
                                                '2':556, '3':556, '4':556, 
                                                '5':556, '6':556, '7':556, 
                                                '8':556, '9':556, ':':278, 
                                                ';':278, '<':584, '=':584, 
                                                '>':584, '?':556, '@':1015, 
                                                'A':667, 'B':667, 'C':722, 
                                                'D':722, 'E':667, 'F':611, 
                                                'G':778, 'H':722, 'I':278, 
                                                'J':500, 'K':667, 'L':556, 
                                                'M':833, 'N':722, 'O':778, 
                                                'P':667, 'Q':778, 'R':722, 
                                                'S':667, 'T':611, 'U':722, 
                                                'V':667, 'W':944, 'X':667, 
                                                'Y':667, 'Z':611, '[':278, 
                                                '\\':278, ']':278, '^':469, 
                                                '_':556, '`':222, 'a':556, 
                                                'b':556, 'c':500, 'd':556, 
                                                'e':556, 'f':278, 'g':556, 
                                                'h':556, 'i':222, 'j':222, 
                                                'k':500, 'l':222, 'm':833, 
                                                'n':556, 'o':556, 'p':556, 
                                                'q':556, 'r':333, 's':500, 
                                                't':278, 'u':556, 'v':500, 
                                                'w':722, 'x':500, 'y':500, 
                                                'z':500, '{':334, '|':260, 
                                                '}':334, '~':584}
        self.font_width['Helvetica'] = {' ':278, '!':278, '"':355, '#':556, 
                                        '$':556, '%':889, '&':667, "'":222, 
                                        '(':333, ')':333, '*':389, '+':584, 
                                        ',':278, '-':333, '.':278, '/':278, 
                                        '0':556, '1':556, '2':556, '3':556, 
                                        '4':556, '5':556, '6':556, '7':556, 
                                        '8':556, '9':556, ':':278, ';':278, 
                                        '<':584, '=':584, '>':584, '?':556, 
                                        '@':1015, 'A':667, 'B':667, 'C':722, 
                                        'D':722, 'E':667, 'F':611, 'G':778, 
                                        'H':722, 'I':278, 'J':500, 'K':667, 
                                        'L':556, 'M':833, 'N':722, 'O':778, 
                                        'P':667, 'Q':778, 'R':722, 'S':667, 
                                        'T':611, 'U':722, 'V':667, 'W':944, 
                                        'X':667, 'Y':667, 'Z':611, '[':278, 
                                        '\\':278, ']':278, '^':469, '_':556, 
                                        '`':222, 'a':556, 'b':556, 'c':500, 
                                        'd':556, 'e':556, 'f':278, 'g':556, 
                                        'h':556, 'i':222, 'j':222, 'k':500, 
                                        'l':222, 'm':833, 'n':556, 'o':556, 
                                        'p':556, 'q':556, 'r':333, 's':500, 
                                        't':278, 'u':556, 'v':500, 'w':722, 
                                        'x':500, 'y':500, 'z':500, '{':334, 
                                        '|':260, '}':334, '~':584}
        self.font_width['Symbol'] = {' ':250, '!':333, '"':713, '#':500, '$':549, 
                                     '%':833, '&':778, "'":439, '(':333, ')':333, 
                                     '*':500, '+':549, ',':250, '-':549, '.':250, 
                                     '/':278, '0':500, '1':500, '2':500, '3':500, 
                                     '4':500, '5':500, '6':500, '7':500, '8':500, 
                                     '9':500, ':':278, ';':278, '<':549, '=':549, 
                                     '>':549, '?':444, '@':549, 'A':722, 'B':667, 
                                     'C':722, 'D':612, 'E':611, 'F':763, 'G':603, 
                                     'H':722, 'I':333, 'J':631, 'K':722, 'L':686, 
                                     'M':889, 'N':722, 'O':722, 'P':768, 'Q':741, 
                                     'R':556, 'S':592, 'T':611, 'U':690, 'V':439, 
                                     'W':768, 'X':645, 'Y':795, 'Z':611, '[':333, 
                                     '\\':863, ']':333, '^':658, '_':500, '`':500, 
                                     'a':631, 'b':549, 'c':549, 'd':494, 'e':439, 
                                     'f':521, 'g':411, 'h':603, 'i':329, 'j':603, 
                                     'k':549, 'l':549, 'm':576, 'n':521, 'o':549, 
                                     'p':549, 'q':521, 'r':549, 's':603, 't':439, 
                                     'u':576, 'v':713, 'w':686, 'x':493, 'y':686, 
                                     'z':494, '{':480, '|':200, '}':480, '~':549}
        self.font_width['Times-Bold'] = {' ':250, '!':333, '"':555, '#':500, 
                                         '$':500, '%':1000, '&':833, "'":333, 
                                         '(':333, ')':333, '*':500, '+':570, 
                                         ',':250, '-':333, '.':250, '/':278, 
                                         '0':500, '1':500, '2':500, '3':500, 
                                         '4':500, '5':500, '6':500, '7':500, 
                                         '8':500, '9':500, ':':333, ';':333, 
                                         '<':570, '=':570, '>':570, '?':500, 
                                         '@':930, 'A':722, 'B':667, 'C':722, 
                                         'D':722, 'E':667, 'F':611, 'G':778, 
                                         'H':778, 'I':389, 'J':500, 'K':778, 
                                         'L':667, 'M':944, 'N':722, 'O':778, 
                                         'P':611, 'Q':778, 'R':722, 'S':556, 
                                         'T':667, 'U':722, 'V':722, 'W':1000, 
                                         'X':722, 'Y':722, 'Z':667, '[':333, 
                                         '\\':278, ']':333, '^':581, '_':500, 
                                         '`':333, 'a':500, 'b':556, 'c':444, 
                                         'd':556, 'e':444, 'f':333, 'g':500, 
                                         'h':556, 'i':278, 'j':333, 'k':556, 
                                         'l':278, 'm':833, 'n':556, 'o':500, 
                                         'p':556, 'q':556, 'r':444, 's':389, 
                                         't':333, 'u':556, 'v':500, 'w':722, 
                                         'x':500, 'y':500, 'z':444, '{':394, 
                                         '|':220, '}':394, '~':520}
        self.font_width['Times-BoldItalic'] = {' ':250, '!':389, '"':555, '#':500, 
                                               '$':500, '%':833, '&':778, "'":333, 
                                               '(':333, ')':333, '*':500, '+':570, 
                                               ',':250, '-':333, '.':250, '/':278, 
                                               '0':500, '1':500, '2':500, '3':500, 
                                               '4':500, '5':500, '6':500, '7':500, 
                                               '8':500, '9':500, ':':333, ';':333, 
                                               '<':570, '=':570, '>':570, '?':500, 
                                               '@':832, 'A':667, 'B':667, 'C':667, 
                                               'D':722, 'E':667, 'F':667, 'G':722, 
                                               'H':778, 'I':389, 'J':500, 'K':667, 
                                               'L':611, 'M':889, 'N':722, 'O':722, 
                                               'P':611, 'Q':722, 'R':667, 'S':556, 
                                               'T':611, 'U':722, 'V':667, 'W':889, 
                                               'X':667, 'Y':611, 'Z':611, '[':333, 
                                               '\\':278, ']':333, '^':570, 
                                               '_':500, '`':333, 'a':500, 'b':500, 
                                               'c':444, 'd':500, 'e':444, 'f':333, 
                                               'g':500, 'h':556, 'i':278, 'j':278, 
                                               'k':500, 'l':278, 'm':778, 'n':556, 
                                               'o':500, 'p':500, 'q':500, 'r':389, 
                                               's':389, 't':278, 'u':556, 'v':444, 
                                               'w':667, 'x':500, 'y':444, 'z':389, 
                                               '{':348, '|':220, '}':348, '~':570
                                               }
        self.font_width['Times-Italic'] = {' ':250, '!':333, '"':420, '#':500, 
                                           '$':500, '%':833, '&':778, "'":333, 
                                           '(':333, ')':333, '*':500, '+':675, 
                                           ',':250, '-':333, '.':250, '/':278, 
                                           '0':500, '1':500, '2':500, '3':500, 
                                           '4':500, '5':500, '6':500, '7':500, 
                                           '8':500, '9':500, ':':333, ';':333, 
                                           '<':675, '=':675, '>':675, '?':500, 
                                           '@':920, 'A':611, 'B':611, 'C':667, 
                                           'D':722, 'E':611, 'F':611, 'G':722, 
                                           'H':722, 'I':333, 'J':444, 'K':667, 
                                           'L':556, 'M':833, 'N':667, 'O':722, 
                                           'P':611, 'Q':722, 'R':611, 'S':500, 
                                           'T':556, 'U':722, 'V':611, 'W':833, 
                                           'X':611, 'Y':556, 'Z':556, '[':389, 
                                           '\\':278, ']':389, '^':422, '_':500, 
                                           '`':333, 'a':500, 'b':500, 'c':444, 
                                           'd':500, 'e':444, 'f':278, 'g':500, 
                                           'h':500, 'i':278, 'j':278, 'k':444, 
                                           'l':278, 'm':722, 'n':500, 'o':500, 
                                           'p':500, 'q':500, 'r':389, 's':389, 
                                           't':278, 'u':500, 'v':444, 'w':667, 
                                           'x':444, 'y':444, 'z':389, '{':400, 
                                           '|':275, '}':400, '~':541}
        self.font_width['Times-Roman'] = {' ':250, '!':333, '"':408, '#':500, 
                                          '$':500, '%':833, '&':778, "'":333, 
                                          '(':333, ')':333, '*':500, '+':564, 
                                          ',':250, '-':333, '.':250, '/':278, 
                                          '0':500, '1':500, '2':500, '3':500, 
                                          '4':500, '5':500, '6':500, '7':500, 
                                          '8':500, '9':500, ':':278, ';':278, 
                                          '<':564, '=':564, '>':564, '?':444, 
                                          '@':921, 'A':722, 'B':667, 'C':667, 
                                          'D':722, 'E':611, 'F':556, 'G':722, 
                                          'H':722, 'I':333, 'J':389, 'K':722, 
                                          'L':611, 'M':889, 'N':722, 'O':722, 
                                          'P':556, 'Q':722, 'R':667, 'S':556, 
                                          'T':611, 'U':722, 'V':722, 'W':944, 
                                          'X':722, 'Y':722, 'Z':611, '[':333, 
                                          '\\':278, ']':333, '^':469, '_':500, 
                                          '`':333, 'a':444, 'b':500, 'c':444, 
                                          'd':500, 'e':444, 'f':333, 'g':500, 
                                          'h':500, 'i':278, 'j':278, 'k':500, 
                                          'l':278, 'm':778, 'n':500, 'o':500, 
                                          'p':500, 'q':500, 'r':333, 's':389, 
                                          't':278, 'u':500, 'v':500, 'w':722, 
                                          'x':500, 'y':500, 'z':444, '{':480, 
                                          '|':200, '}':480, '~':541}
        self.font_width['ZapfDingbats'] = {' ':278, '!':974, '"':961, '#':974, 
                                           '$':980, '%':719, '&':789, "'":790, 
                                           '(':791, ')':690, '*':960, '+':939, 
                                           ',':549, '-':855, '.':911, '/':933, 
                                           '0':911, '1':945, '2':974, '3':755, 
                                           '4':846, '5':762, '6':761, '7':571, 
                                           '8':677, '9':763, ':':760, ';':759, 
                                           '<':754, '=':494, '>':552, '?':537, 
                                           '@':577, 'A':692, 'B':786, 'C':788, 
                                           'D':788, 'E':790, 'F':793, 'G':794, 
                                           'H':816, 'I':823, 'J':789, 'K':841, 
                                           'L':823, 'M':833, 'N':816, 'O':831, 
                                           'P':923, 'Q':744, 'R':723, 'S':749, 
                                           'T':790, 'U':792, 'V':695, 'W':776, 
                                           'X':768, 'Y':792, 'Z':759, '[':707, 
                                           '\\':708, ']':682, '^':701, '_':826, 
                                           '`':815, 'a':789, 'b':789, 'c':707, 
                                           'd':687, 'e':696, 'f':689, 'g':786, 
                                           'h':787, 'i':713, 'j':791, 'k':785, 
                                           'l':791, 'm':873, 'n':761, 'o':762, 
                                           'p':762, 'q':759, 'r':759, 's':892, 
                                           't':892, 'u':788, 'v':784, 'w':438, 
                                           'x':138, 'y':277, 'z':415, '{':392, 
                                           '|':392, '}':668, '~':668}
        self.font_list = ['Courier-Bold', 'Courier-BoldOblique',
                          'Courier-Oblique', 'Courier', 'Helvetica-Bold',
                          'Helvetica-BoldOblique', 'Helvetica-Oblique',
                          'Helvetica', 'Symbol', 'Times-Bold',
                          'Times-BoldItalic', 'Times-Italic',
                          'Times-Roman', 'ZapfDingbats']
        return

    def get_font_list(self):
        return self.font_list

    def get_string_width(self, font, size, string):
        if font == 'default':
            font = 'Helvetica'
        if font not in self.font_list:
            print('font not supported', font)
            return
        total_width = 0
        for s in string:
            total_width += self.font_width[font][s]
        return total_width * size / 1000.0

#
# --class-- writer IGNORE
#
# Simple helper class to buffer commands and write output files.
# Not of general use.
#
class writer:
    def __init__(self,
                 ):
        self.commands = []
        return

    # record ...
    def out_after(self, out_str, index):
        self.commands.insert(index, out_str)
        return index + 1

    # add a new command
    def out(self, out_str):
        self.commands.append(out_str)
        return len(self.commands)

    # add a command to the previously added line
    def outnl(self, out_str):
        assert(len(self.commands) > 0)
        idx = len(self.commands) - 1
        self.commands[idx] = self.commands[idx] + out_str
        return len(self.commands)

    # output the commands
    def dump(self, outfile):
        if outfile == 'stdout':
            for line in self.commands:
                print(line)
        else:
            fd = open(outfile, 'w')
            for line in self.commands:
                fd.write(line + '\n')
            fd.close()
        return

#
# --class-- postscript_drawer IGNORE
#
# Low-level drawing commands for a postscript canvas.
# Used by upper-level 'canvas' class to make eps plots.
#
class postscript_drawer:
    def __init__(self,
                 colors,
                 fontinfo,
                 default_font,
                 writer,
                 title,
                 program,
                 version,
                 script,
                 width,
                 height,
                 ):
        self.colors = colors
        self.fontinfo = fontinfo
        self.default_font = default_font
        self.writer = writer
        self.title = title
        self.program = program
        self.version = version
        self.script = script
        self.width = width
        self.height = height
        self.date = str(time.strftime('%X %x %Z'))

        self.gsave_cnt = 0
        self.grestore_cnt = 0

        # list of all fonts 
        self.all_fonts = self.fontinfo.get_font_list()
        assert(default_font in self.all_fonts)
        self.font_list = []
        return

    # postscript_drawer: make_header
    def make_header(self):
        # generic eps header
        self.writer.out('%!PS-Adobe-2.0 EPSF-2.0')
        self.writer.out('%%Title: ' + str(self.title))
        self.writer.out('%%Creator: '+ str(self.program) + ' version:' + \
                        str(self.version) + ' script:' + os.path.abspath(self.script) + \
                        ' host:'+socket.gethostname())
        self.writer.out('%%CreationDate: ' + str(self.date))
        self.writer.out('%%DocumentFonts: (atend)')
        self.writer.out('%%BoundingBox: 0 0 ' + str(self.width) + ' ' + \
                 str(self.height))
        self.writer.out('%%Orientation: Portrait')
        self.writer.out('%%EndComments')

        # zdraw dictionary
        self.writer.out('% zdraw dictionary')
        self.writer.out('/zdict 256 dict def')
        self.writer.out('zdict begin')
        self.writer.out('/cpx 0 def')
        self.writer.out('/cpy 0 def')
        self.writer.out('/reccp {currentpoint /cpy exch def /cpx exch def} bind def')
        self.writer.out('/m {moveto} bind def')
        self.writer.out('/l {lineto} bind def')
        self.writer.out('/mr {rmoveto} bind def')
        self.writer.out('/lr {rlineto} bind def')
        self.writer.out('/np {newpath} bind def')
        self.writer.out('/cp {closepath} bind def')
        self.writer.out('/st {stroke} bind def')
        self.writer.out('/fl {fill} bind def')
        self.writer.out('/gs {gsave} bind def')
        self.writer.out('/gr {grestore} bind def')
        self.writer.out('/slw {setlinewidth} bind def')
        self.writer.out('/slc {setlinecap} bind def')
        self.writer.out('/slj {setlinejoin} bind def')
        self.writer.out('/sc  {setrgbcolor} bind def')
        self.writer.out('/sd  {setdash} bind def')
        self.writer.out('/lshow {show reccp} def')
        self.writer.out('/rshow {dup stringwidth pop neg 0 mr show reccp} def')
        self.writer.out('/cshow {dup stringwidth pop -2 div 0 mr show reccp} def')
        self.writer.out('end')
        self.writer.out('zdict begin')
        return

    # postscript_drawer: make_trailer
    def make_trailer(self):
        # do some checks
        self.gcheck()

        # generic eps trailer
        self.writer.out('% zplot .eps epilogue')
        self.writer.out('end')
        self.writer.out('showpage')
        self.writer.out('%%Trailer')

        # make font list
        font_list = self.font_list
        if len(font_list) > 0:
            font_str = font_list[0]
            for i in range(1, len(font_list)):
                font_str = font_str + ' ' + font_list[i]
            self.writer.out('%%DocumentFonts: ' + font_str)
        else:
            self.writer.out('%%DocumentFonts: ')
        return

    #
    # Commands used to draw graphics and text to ps canvas
    #

    # postscript_drawer: getcolor
    def getcolor(self, value):
        return value

    # postscript_drawer: gsave
    def gsave(self):
        self.writer.out('gs')
        self.gsave_cnt = self.gsave_cnt + 1
        return

    # postscript_drawer: grestore
    def grestore(self):
        self.writer.out('gr')
        self.grestore_cnt = self.grestore_cnt + 1
        return

    # postscript_drawer: gcheck
    def gcheck(self):
        if self.gsave_cnt != self.grestore_cnt:
            abort('mismatch in gsaves/grestores')
        return

    # postscript_drawer: newpath
    def newpath(self, path_type=''):
        self.writer.out('np')
        return

    # postscript_drawer: moveto
    def moveto(self, p1, p2):
        self.writer.out(str(float(p1)) + ' ' + str(float(p2)) + ' m')
        return

    # postscript_drawer: curveto
    def curveto(self, x1, y1, x2, y2, x3, y3):
        self.writer.out('%.2f %.2f %.2f %.2f %.2f %.2f curveto' % \
                   (x1, y1, x2, y2, x3, y3))
        return

    # postscript_drawer: rmoveto
    def rmoveto(self, p1, p2):
        self.writer.out(str(float(p1)) + ' ' + str(float(p2)) + ' mr')
        return

    # postscript_drawer: lineto
    def lineto(self, p1, p2):
        self.writer.out(str(float(p1)) + ' ' + str(float(p2)) + ' l')
        return

    # postscript_drawer: rlineto
    def rlineto(self, p1, p2):
        self.writer.out(str(float(p1)) + ' ' + str(float(p2)) + ' lr')
        return

    # postscript_drawer: rotate
    def rotate(self, angle):
        self.writer.out(str(angle) + ' rotate')
        return
        
    # postscript_drawer: show
    def show(self, text, anchor):
        if anchor == 'c':
            self.writer.out('('+text+') cshow')
        elif anchor == 'l':
            self.writer.out('('+text+') lshow')
        elif anchor == 'r':
            self.writer.out('('+text+') rshow')
        else:
            abort('bad anchor: ' + anchor)
        return

    # postscript_drawer: begintext
    def begintext(self):
        self.gsave()
        return
    
    # postscript_drawer: endtext
    def endtext(self):
        self.grestore()
        return

    # postscript_drawer: showtext
    def showtext(self, text, x, y, dx, dy, xanchor, yanchor, rotate):
        self.moveto(x, y)
        if rotate != 0:
            self.gsave()
            self.rotate(rotate)
        self.rmoveto(dx, dy)
        self.show(text, 'l')
        if rotate != 0:
            self.grestore()
        return

    # postscript_drawer: closepath
    def closepath(self):
        self.writer.out('cp')
        return

    # postscript_drawer: setcolor
    def setcolor(self, value):
        tmp = value.split(',')
        if len(tmp) > 1:
            c = '%s %s %s' % (tmp[0], tmp[1], tmp[2])
        else:
            c = self.colors.get(value)
        self.writer.out(c + ' sc')
        return

    # postscript_drawer: setfillcolor
    def setfillcolor(self, value):
        return self.setcolor(value)

    # postscript_drawer: setlinecolor
    def setlinecolor(self, value):
        return self.setcolor(value)

    # postscript_drawer: setlinewidth
    def setlinewidth(self, linewidth):
        self.writer.out(str(float(linewidth)) + ' slw')
        return

    # postscript_drawer: setlinecap
    def setlinecap(self, linecap):
        self.writer.out(str(int(linecap)) + ' slc')
        return

    # postscript_drawer: setlinejoin
    def setlinejoin(self, linejoin):
        self.writer.out(str(int(linejoin)) + ' slj')
        return

    # postscript_drawer: setlinedash
    def setlinedash(self, linedash):
        self.writer.out('[ ')
        for seg in linedash:
            self.writer.outnl(str(seg) + ' ')
        self.writer.outnl('] 0 sd')
        return

    # postscript_drawer: fill
    def fill(self):
        self.writer.out('fl')
        return

    # postscript_drawer: stroke
    def stroke(self):
        self.writer.out('st')

    # postscript_drawer: rectangle
    def rectangle(self, x1, y1, x2, y2):
        self.moveto(x1, y1)
        self.lineto(x1, y2)
        self.lineto(x2, y2)
        self.lineto(x2, y1)
        return

    # postscript_drawer: scale
    def scale(self, x, y):
        self.writer.out(str(x) + ' ' + str(y) + ' scale')
        return

    # postscript_drawer: arc
    def arc(self, x, y, radius, start, end):
        self.writer.out(str(x) + ' ' + str(y) + ' ' + str(radius) + ' ' + \
                   str(start) + ' ' + str(end) + ' arc')
        return

    # postscript_drawer: circle
    def circle(self, x, y, radius):
        self.arc(x, y, radius, 0, 360)

    # postscript_drawer: clip
    def clip(self):
        self.writer.out('clip')
        return

    # postscript_drawer: clippoly
    def clippoly(self, coord):
        self.newpath()
        self.moveto(coord[0][0], coord[0][1])
        for i in range(1, len(coord)):
            self.lineto(coord[i][0], coord[i][1])
        self.closepath()
        self.clip()
        return ''

    # postscript_drawer: clipcircle
    def clipcircle(self, x, y, radius):
        self.newpath()
        self.circle(x, y, radius)
        self.closepath()
        self.clip()
        return ''

    # postscript_drawer: addfont
    def addfont(self, font):
        if font not in self.all_fonts:
            abort('bad font: %s' % font)
        if font not in self.font_list:
            self.font_list.append(font)
        return

    # postscript_drawer: setfont
    def setfont(self, face, size):
        if face == 'default':
            face = self.default_font
        self.addfont(face)
        self.writer.out('(' + face + ') findfont ' + str(size) +
                   ' scalefont setfont')
        return

    # postscript_drawer: setpattern
    def setpattern(self, pattern):
        return

#
# --class-- pdf_drawer IGNORE
#
# Low-level drawing commands for a PDF canvas.
# Used by upper-level 'canvas' class to make PDF plots.
#
class pdf_drawer:
    def __init__(self,
                 colors,
                 fontinfo,
                 default_font,
                 writer,
                 title,
                 program,
                 version,
                 script,
                 width,
                 height
                 ):
        self.colors = colors
        self.fontinfo = fontinfo
        self.default_font = default_font
        self.writer = writer
        self.title = title
        self.program = program
        self.version = version
        self.script = script
        self.width = width
        self.height = height
        self.date = str(time.strftime('%X %x %Z'))

        self.fontlist = self.fontinfo.get_font_list()

        self.fontmap = {}
        self.commands = []
        return

    # http://www.amccormack.net/2012-01-22-anatomy-of-a-pdf-document.html
    #   /Resources << /ProcSet 6 0 R /Font << /F1 7 0 R >> >>
    def make_header(self):
        self.object_lengths = []
        
        self.__pdf_out('%PDF-1.7')
        self.__pdf_out('1 0 obj <</Type /Catalog /Pages 2 0 R>> endobj')
        self.__pdf_out('2 0 obj <</Type /Pages /Kids [3 0 R] /Count 1>> endobj')
        self.__pdf_out('3 0 obj <</Type /Page ' + \
                    '/MediaBox [0 0 %d %d] ' % (self.width, self.height) + \
                    '/Parent 2 0 R /Resources 4 0 R /Contents %d 0 R>> ' % \
                    (5 + len(self.fontlist)) + 'endobj')
        out_str = '4 0 obj <</Font <<'
        for i in range(len(self.fontlist)):
            out_str += '/F%d %d 0 R ' % (i+1, i+5)
            self.fontmap[self.fontlist[i]] = i+1
        out_str += '>>>> endobj'
        self.__pdf_out(out_str)
        num = 5
        for f in self.fontlist:
            self.__pdf_out('%d 0 obj <</Type /Font /Subtype /Type1 ' % num + \
                        '/BaseFont /%s>> endobj' % f)
            num += 1
        return

    def make_trailer(self):
        # put all the drawing commands, etc., into this one object
        tmp_str = ''
        for c in self.commands:
            tmp_str += '%s\n' % c

        out_str = '%d 0 obj <</Length %d>>\n' % (len(self.object_lengths),
                                                 len(tmp_str))
        out_str += 'stream\n'
        out_str += tmp_str
        out_str += 'endstream\n'
        out_str += 'endobj'
        # output the one object here
        self.__pdf_out(out_str)

        # And then (finally) the trailer...
        # First is this little table at the end that has the byte offset
        # of each object in the PDF document.
        num_objects = len(self.object_lengths)
        self.__pdf_out('xref')
        self.__pdf_out('0 %d' % num_objects) 
        self.__pdf_out('0000000000 65535 f')
        cnt = 0
        for i in range(num_objects):
            e = self.object_lengths[i]
            cnt += e

            # have to output this as length 10 number with 0's leading
            # the number (cnt) is the byte offset of the object, from 0-6,
            # in the PDF
            target_len = 10
            curr_len = len(str(cnt))
            out_str = ''
            for i in range(target_len - curr_len):
                out_str += '0'
            out_str += str(cnt)
            self.__pdf_out('%s 00000 n' % out_str)
        # Then a little bit that points to the root object
        self.__pdf_out('trailer <</Size %d/Root 1 0 R>>' % num_objects)
        # And a little thing that gives a byte offset of the offset table
        self.__pdf_out('startxref')
        cnt = 0
        for e in self.object_lengths:
            cnt += e
        # byte offset of the last crossref section
        self.__pdf_out('%d' % cnt)
        self.__pdf_out('%%EOF')
        return

    # pdf_drawer: __pdf_out
    # Wrapper for pdf object to be output
    def __pdf_out(self, s):
        length = len(s)
        self.writer.out(s)
        self.object_lengths.append(length + 1)
        return

    # pdf_drawer: __out
    def __out(self, command):
        self.commands.append(command)
        return

    # pdf_drawer: __setcolor
    def __setcolor(self, value, command):
        tmp = value.split(',')
        if len(tmp) > 1:
            c = '%s %s %s' % (tmp[0], tmp[1], tmp[2])
        else:
            c = self.colors.get(value)
        self.__out(c + ' %s' % command)
        return

    # pdf_drawer: getcolor
    def getcolor(self, value):
        return value

    # pdf_drawer: setlinecolor
    def setlinecolor(self, value):
        self.__setcolor(value, ' RG')
        return

    # pdf_drawer: setfillcolor
    def setfillcolor(self, value):
        self.__setcolor(value, ' rg')
        return

    # pdf_drawer: setlinewidth
    def setlinewidth(self, value):
        self.__out('%.2f w' % float(value))
        return

    # pdf_drawer: setlinecap
    def setlinecap(self, value):
        value = int(value)
        if value != 0 and value != 1 and value != 2:
            print('bad linecap', value)
            return
        self.__out('%d J' % value)
        return

    # pdf_drawer: setlinejoin
    def setlinejoin(self, value):
        value = int(value)
        if value != 0 and value != 1 and value != 2:
            print('+ bad linejoin', value)
            return
        self.__out('%d j' % value)
        return

    # pdf_drawer: setlinedash
    def setlinedash(self, value):
        dashpattern = ''
        for d in value:
            dashpattern += '%s ' % str(d)
        self.__out('[%s] 0 d' % dashpattern)
        return

    # pdf_drawer: moveto
    def moveto(self, x, y):
        self.__out('%.2f %.2f m' % (float(x), float(y)))
        return

    # pdf_drawer: curveto
    def curveto(self, x1, y1, x2, y2, x3, y3):
        self.__out('%.2f %.2f %.2f %.2f %.2f %.2f c' % \
                    (x1, y1, x2, y2, x3, y3))
        return

    # pdf_drawer: scale
    def scale(self, x, y):
        # self.writer.out(str(x) + ' ' + str(y) + ' scale')
        self.__out('%f 0 0 %f 0 0 cm' % (x, y))
        return

    # pdf_drawer: circle
    def circle(self, x, y, radius):
        # Have to assemble the circle from bezier curves(!)
        # One good description of this is found here (URL over next 3 lines):
        # http://stackoverflow.com/questions/1960786/
        #   how-do-you-draw-filled-and-unfilled-circles-with-pdf-primitives/
        #   2007782#2007782
        magic = radius * 0.552;
        x0p, y0p = x - radius, y
        self.moveto(x0p, y0p)

        x0p, y0p = x - radius, y
        x1, y1 = x0p, y0p + magic
        x2, y2 = x0p + radius - magic, y0p + radius
        x3, y3 = x0p + radius, y0p + radius
        self.curveto(x1, y1, x2, y2, x3, y3)

        x0p, y0p = x, y + radius
        x1, y1 = x0p + magic, y0p              
        x2, y2 = x0p + radius, y0p - radius + magic
        x3, y3 = x0p + radius, y0p - radius         
        self.curveto(x1, y1, x2, y2, x3, y3)

        x0p, y0p = x + radius, y
        x1, y1 = x0p, y0p - magic
        x2, y2 = x0p - radius + magic, y0p - radius    
        x3, y3 = x0p - radius, y0p - radius    
        self.curveto(x1, y1, x2, y2, x3, y3)

        x0p, y0p = x, y - radius
        x1, y1 = x0p - magic, y0p
        x2, y2 = x0p - radius, y0p + radius - magic   
        x3, y3 = x0p - radius, y0p + radius    
        self.curveto(x1, y1, x2, y2, x3, y3)
        return

    # pdf_drawer: lineto
    def lineto(self, x, y):
        self.__out('%.2f %.2f l' % (float(x), float(y)))
        return

    # pdf_drawer: rectangle
    def rectangle(self, x1, y1, x2, y2):
        self.moveto(x1, y1)
        self.lineto(x1, y2)
        self.lineto(x2, y2)
        self.lineto(x2, y1)
        self.lineto(x1, y1)
        return

    # pdf_drawer: newpath
    def newpath(self, path_type=''):
        # PDF has no "newpath" construct
        return

    # pdf_drawer: closepath
    def closepath(self):
        self.__out('h')
        return

    # pdf_drawer: stroke
    def stroke(self):
        self.__out('S')
        return

    # pdf_drawer: fill
    def fill(self):
        self.__out('f')
        return

    # pdf_drawer: gsave
    def gsave(self):
        self.__out('q')
        return

    # pdf_drawer: grestore
    def grestore(self):
        self.__out('Q')
        return

    # pdf_drawer: begintext
    def begintext(self):
        self.__out('BT')
        return

    # pdf_drawer: endtext
    def endtext(self):
        self.__out('ET')
        return

    # pdf_drawer: textmoveto
    def __textmoveto(self, x, y, dx, dy):
        self.__out('%.2f %.2f Td' % (x + dx, y + dy))
        return

    # pdf_drawer: textmovetorotate
    def __textmovetorotate(self, x, y, dx, dy, angle):
        angle = math.radians(angle)
        cos, sin = math.cos(angle), math.sin(angle)
        xdx, xdy = dx * cos, dx * sin
        ydx, ydy = -dy * sin, dy * cos
        self.__out('%.2f %.2f %.2f %.2f %.2f %.2f Tm' % (cos, sin, -sin, cos,
                                                         x + xdx + ydx,
                                                         y + xdy + ydy))
        return

    # pdf_drawer: __puttext
    def __puttext(self, text):
        self.__out('(%s) Tj' % text)
        return

    # pdf_drawer: showtext
    def showtext(self, text, x, y, dx, dy, xanchor, yanchor, rotate):
        if rotate == 0:
            self.__textmoveto(x, y, dx, dy)
        else:
            self.__textmovetorotate(x, y, dx, dy, rotate)
        self.__puttext(text)
        return

    # pdf_drawer: setfont
    def setfont(self, font, size):
        if font == 'default':
            font = self.default_font
        if font not in self.fontmap:
            print('font %s not found' % font)
            return
        fontnum = self.fontmap[font]
        self.__out('/F%d %.2f Tf' % (fontnum, size))
        return

    # pdf_drawer: clip
    def clip(self):
        self.__out('W')
        self.__out('n')
        return

    # pdf_drawer: clippoly
    def clippoly(self, coord):
        self.moveto(coord[0][0], coord[0][1])
        for i in range(1, len(coord)):
            self.lineto(coord[i][0], coord[i][1])
        self.closepath()
        self.clip()
        return ''

    # pdf_drawer: clipcircle
    def clipcircle(self, x, y, radius):
        self.circle(x, y, radius)
        self.clip()
        return ''

    # pdf_drawer: setpattern
    def setpattern(self, pattern):
        return

#
# --class-- svg_drawer IGNORE
#
# Low-level drawing commands for an SVG canvas.
# Used by upper-level 'canvas' class to make SVG plots.
#
class svg_drawer:
    def __init__(self,
                 colors,
                 fontinfo,
                 default_font,
                 writer,
                 title,
                 program,
                 version,
                 script,
                 width,
                 height
                 ):
        self.colors = colors
        self.fontinfo = fontinfo
        self.default_font = default_font
        self.writer = writer
        self.title = title
        self.program = program
        self.version = version
        self.script = script
        self.width = width
        self.height = height
        self.date = str(time.strftime('%X %x %Z'))

        self.fontlist = self.fontinfo.get_font_list()
        self.fontmap = {}

        # need this for proper clipping
        self.poly_clip_counter = 0 
        self.poly_clip_list = []
        return

    # http://www.amccormack.net/2012-01-22-anatomy-of-a-pdf-document.html
    #   /Resources << /ProcSet 6 0 R /Font << /F1 7 0 R >> >>
    def make_header(self):
        # ADD SOME INFO ABOUT HOW TO INCLUDE INTO HTML...
        self.__comment(' Include into html file with following line: ')
        self.__comment(' <img width="%.2f" height="%.2f" src="%s"> ' % \
                       (float(self.width), float(self.height), self.title))

        #
        # init svg output header
        #
        self.defsIndex = \
                       self.__out('<svg xmlns="http://www.w3.org/2000/svg" ' + \
                                  'xmlns:xlink="http://www.w3.org/1999/xlink" ' + \
                                  'width="%.2f" height="%.2f">' % (float(self.width), \
                                                                   float(self.height)))
        return

    def __pattern_num_to_name(self, index):
        return 'zplot_pattern_%d' % index

    def make_trailer(self):
        self.__out('</svg>')

        # insert clip definitions into beginning of SVG
        index = self.__out_after('<defs>', self.defsIndex)
        for i in range(len(self.poly_clip_list)):
            pattern_name = self.__pattern_num_to_name(i)
            out_str = '<clipPath id="%s"> ' % pattern_name
            element = self.poly_clip_list[i]

            # figure out which type of clipping this is...
            # options right now are just polygon or circle
            if element[0] == 'poly':
                coord_list = self.poly_clip_list[i][1]
                x, y = coord_list[0][0], self.__converty(coord_list[0][1])
                out_str += '<polyline points="%.2f,%.2f' % (x, y)
                for j in range(1, len(coord_list)):
                    coord = self.poly_clip_list[i][1][j]
                    out_str += ' %.2f,%.2f' % (coord[0],
                                               self.__converty(coord[1]))
                out_str += '"/> </clipPath>'
            elif element[0] == 'circle':
                x, y, radius = self.poly_clip_list[i][1]
                out_str += '<circle cx="%.2f" cy="%.2f" r="%.2f"/> </clipPath>' % \
                           (x, self.__converty(y), radius)
            else:
                abort('bad svg definition [%s]' % element[0])

            # now add out_str to the output in the right location
            index = self.__out_after(out_str, index)
        self.__out_after('</defs>', index)
        return

    # svg_drawer: __out
    def __out(self, command):
        return self.writer.out(command)

    # svg_drawer: __outnl
    def __outnl(self, command):
        return self.writer.outnl(command)

    # svg_drawer: __out_after
    def __out_after(self, out_str, index):
        self.writer.out_after(out_str, index)
        return index + 1

    # svg_drawer: __comment
    def __comment(self, msg):
        self.__out('<!--')
        self.__outnl(msg)
        self.__outnl('-->')

    # svg_drawer: __converty
    def __converty(self, y):
        return self.height - y

    # svg_drawer: getcolor
    def getcolor(self, value):
        return self.colors.get_as_hex(value)

    # svg_drawer: gsave
    def gsave(self):
        return

    # svg_drawer: grestore
    def grestore(self):
        return

    # svg_drawer: setfillcolor
    def setfillcolor(self, value):
        self.current_fillcolor = self.colors.get_as_hex(value)
        # print('setting FILL color', self.current_fillcolor)
        return

    # svg_drawer: setlinecolor
    def setlinecolor(self, value):
        self.current_linecolor = self.colors.get_as_hex(value)
        # print('setting LINE color', self.current_linecolor)
        return

    # svg_drawer: setlinewidth
    def setlinewidth(self, value):
        self.current_linewidth = float(value)
        self

    # svg_drawer: setlinejoin
    def setlinejoin(self, value):
        if value == 0:
            return
        if value == 1:
            self.current_linejoin = 'round'
        elif linejoin == 2:
            self.current_linejoin = 'bevel'
        else:
            print('bad linejoin [%s]' % value)
        return

    # svg_drawer: setlinecap
    def setlinecap(self, value):
        if value == 0:
            return
        if value == 1:
            self.current_linecap = 'round'
        elif value == 2:
            self.current_linecap = 'square'
        else:
            print('bad linecap [%s]' % value)
        return

    # svg_drawer: setlinedash
    def setlinedash(self, value):
        outdash = ''
        for e in value:
            if outdash == '':
                outdash = str(e)
            else:
                outdash = outdash + ',' + str(e)
        self.current_linedash = outdash
        return

    # svg_drawer: setpattern
    def setpattern(self, pattern):
        self.current_pattern = pattern
        return

    # svg_drawer: scale
    def scale(self, x, y):
        # self.writer.out(str(x) + ' ' + str(y) + ' scale')
        print('svg_drawer: scale not implemented')
        return

    # svg_drawer: newpath
    def newpath(self, path_type='line'):
        self.current_fill      = False
        self.current_fillcolor = 'black'
        self.current_linewidth = 1
        self.current_linecolor = 'black'
        self.current_linedash  = ''
        self.current_linecap   = ''
        self.current_linejoin  = ''
        self.current_pattern   = ''
        self.path_type         = path_type

        if path_type == 'circle':
            self.__out('<circle ')
        else:
            self.__out('<path d="')
        return

    # svg_drawer: circle
    def circle(self, x, y, radius):
        self.__outnl('cx="%.2f" cy="%.2f" r="%.2f" ' % (x, self.__converty(y),
                                                        radius))
        return

    # svg_drawer: fill
    def fill(self):
        self.current_fill = True
        return

    # svg_drawer: closepath
    def closepath(self):
        self.__outnl('Z')
        return

    # svg_drawer: moveto
    def moveto(self, p1, p2):
        self.__outnl('M %.2f,%.2f ' % (p1, self.__converty(p2)))
        return

    # svg_drawer: curveto
    def curveto(self, p1, p2, p3, p4, p5, p6):
        self.__outnl('c %.2f,%.2f %.2f,%.2f %.2f,%.2f ' % \
                     (p1, self.__converty(p2),
                      p3, self.__converty(p4),
                      p5, self.__converty(p6)))
        return

    # svg_drawer: stroke
    def stroke(self):
        if self.path_type == 'line':
            self.__outnl('" ')
        self.__outnl('style="')
        self.__outnl('stroke: %s; ' % self.getcolor(self.current_linecolor))
        self.__outnl('stroke-width: %.2f; ' % self.current_linewidth)
        if self.current_linedash != '':
            self.__outnl('stroke-dasharray: %s; ' % self.current_linedash)
        if self.current_linejoin != '':
            self.__outnl('stroke-linejoin: %s; ' % self.current_linejoin)
        if self.current_linecap != '':
            self.__outnl('stroke-linecap: %s; ' % self.current_linecap)
        if self.current_fill:
            self.__outnl('fill: %s;' % self.current_fillcolor)
        else:
            self.__outnl('fill: none;')
        self.__outnl('"')
        if self.current_pattern != '':
            self.__outnl(' clip-path="url(#%s)"' % self.current_pattern)
        self.__outnl('/>')
        return

    # svg_drawer: lineto
    def lineto(self, p1, p2):
        self.__outnl('L %.2f,%.2f ' % (p1, self.__converty(p2)))
        return

    # svg_drawer: begintext
    def begintext(self):
        self.current_fillcolor = ''
        return

    # svg_drawer: setfont
    def setfont(self, font, size):
        self.current_font = font
        self.current_fontsize = size
        return

    # svg_drawer: showtext
    def showtext(self, text, x, y, dx, dy, xanchor, yanchor, rotate):
        y = self.__converty(y)
        self.__out('<text x="%.2f" y="%.2f" ' % (x, y))
        if rotate != 0:
            self.__outnl('transform="rotate(%.2f %.2f,%.2f)" ' %
                                (float(-rotate), x, y))
        self.__outnl('style="')
        self.__outnl('font-family: %s; ' % self.current_font)
        self.__outnl('font-size: %d; ' % self.current_fontsize)
        if self.current_fillcolor != '':
            self.__outnl('fill: %s; ' % self.getcolor(self.current_fillcolor))

        if xanchor == 'c':
            anchor = 'middle'
        elif xanchor == 'l':
            anchor = 'start'
        elif xanchor == 'r':
            anchor = 'end'

        if yanchor == 'l':
            baseline = 'baseline'
        elif yanchor == 'c':
            baseline = 'middle'
        elif yanchor == 'h':
            baseline = 'hanging'
        
        self.__outnl('text-anchor: %s; ' % anchor)
        self.__outnl('alignment-baseline: %s; ' % baseline)
        self.__outnl('"> ')
        self.__outnl(text)
        self.__outnl('</text>')
        
        return

    # svg_drawer: endtext
    def endtext(self):
        return

    # svg_drawer: rectangle
    def rectangle(self, x1, y1, x2, y2):
        self.moveto(x1, y1)
        self.lineto(x1, y2)
        self.lineto(x2, y2)
        self.lineto(x2, y1)
        self.lineto(x1, y1)
        return

    # svg_drawer: clippoly
    def clippoly(self, coord):
        self.poly_clip_counter += 1 
        self.poly_clip_list.append(('poly', coord))
        return self.__pattern_num_to_name(self.poly_clip_counter - 1)

    # svg_drawer: clipcircle
    def clipcircle(self, x, y, radius):
        self.poly_clip_counter += 1 
        self.poly_clip_list.append(('circle', [x, y, radius]))
        return self.__pattern_num_to_name(self.poly_clip_counter - 1)

#
# --class-- canvas
#
# Use this to make a drawing surface of type eps, pdf, or svg (for now).
# Most simple plots use a single canvas and one or more drawables to get
# their work done. 
#
class canvas:
    def __init__(self,
                 # Canvas type: Can be eps, pdf, svg (for now).
                 canvas_type = 'eps',
                 
                 # Base name of the output file. Output will be
                 # of the form: 'title.canvas_type'
                 title = 'default',

                 # Size of the drawing surface.
                 dimensions = ['3in','2in'],

                 # Default font for text.
                 default_font = 'Helvetica',
                 
                 # Whether to add more info into output file.
                 verbose = False,

                 # Name of the file calling into zplot; recorded in header.
                 script = __file__,
                 ):
        self.canvas_type = canvas_type
        self.title = title
        self.dimensions = dimensions
        self.default_font = default_font
        self.verbose = verbose
        self.script = script

        self.program = 'zplot'
        self.version = 'python version 1.41'

        self.colors = color()
        self.fontinfo = fontsize()
        
        self.output_file = title + '.' + canvas_type

        self.width = self.convert(str(dimensions[0]))
        self.height = self.convert(str(dimensions[1]))

        # simple helper class used to write contents to a file
        self.writer = writer()

        if self.canvas_type == 'eps':
            self.drawer = postscript_drawer(colors=self.colors, fontinfo=self.fontinfo,
                                            default_font=self.default_font, writer=self.writer,
                                            title=self.title, program=self.program,
                                            version=self.version, script=self.script,
                                            width=self.width, height=self.height)
        elif self.canvas_type == 'pdf':
            self.drawer = pdf_drawer(colors=self.colors, fontinfo=self.fontinfo,
                                     default_font=self.default_font, writer=self.writer,
                                     title=self.title, program=self.program,
                                     version=self.version, script=self.script,
                                     width=self.width, height=self.height)
        elif self.canvas_type == 'svg':
            self.drawer = svg_drawer(colors=self.colors, fontinfo=self.fontinfo,
                                     default_font=self.default_font, writer=self.writer,
                                     title=self.title, program=self.program,
                                     version=self.version, script=self.script,
                                     width=self.width, height=self.height)
        else:
            abort('bad canvas type [%s]' % self.canvas_type)

        self.drawer.make_header()
        return

    def render(self):
        self.drawer.make_trailer()
        self.writer.dump(self.output_file)
        return

    #
    # A version string
    #
    def version(self):
        return self.version

    #
    # Used to convert from whatever into points
    #
    def convert(self, unit_str):
        u = unit_str.split('inches')
        if len(u) > 1:
            return float(u[0]) * 72.0
        u = unit_str.split('in')
        if len(u) > 1:
            return float(u[0]) * 72.0
        u = unit_str.split('i')
        if len(u) > 1:
            return float(u[0]) * 72.0
        return float(unit_str)

    #
    # Used to get string width of various fonts
    #
    def get_string_width(self, font, fontsize, text):
        return self.fontinfo.get_string_width(font, fontsize, text)

    #
    # Color help
    #
    def getcolor(self, value):
        return self.drawer.getcolor(value)

    #
    # Use this to draw a shape on the plotting surface. Lots of possibilities,
    # including square, circle, triangle, utriangle, plusline, hline, vline,
    # hvline, xline, dline1, dline2, dline12, diamond, asterisk, ...
    #
    # Amazingly, this is all generic, just built on lines, boxes, circles, etc.
    # 
    def shape(self,
              style     = '',      # the possible shapes
              x         = '',      # x position of shape
              y         = '',      # y position of shape
              size      = 3.0,     # size of shape
              linecolor = 'black', # color of the line of the marker
              linewidth = 1.0,     # width of lines used to draw the marker
              linedash  = 0,       # dash pattern - 0 means no dashes
              fill      = False,   # for some shapes, filling makes sense;
                                   # if desired, mark this true
              fillcolor = 'black', # if filling, use this fill color
              fillstyle = 'solid', # if filling, which fill style to use
              fillsize  = 3.0,     #  size of object in pattern
              fillskip  = 4.0,     # space between object in pattern
              ):
        if style == 'square':
            self.box(coord=[[x-size,y-size],[x+size,y+size]], 
                     linecolor=linecolor, linewidth=linewidth,  fill=fill,
                     fillcolor=fillcolor, fillstyle=fillstyle,
                     fillsize=fillsize, fillskip=fillskip) 
        elif style == 'circle':
            self.circle(coord=[x,y], radius=size, linecolor=linecolor,
                        linewidth=linewidth, fill=fill, fillcolor=fillcolor,
                        fillstyle=fillstyle, fillsize=fillsize,
                        fillskip=fillskip) 
        elif style == 'triangle':
            self.polygon(coord=[[x-size,y-size], [x,y+size], [x+size, y-size]],
                         linecolor=linecolor, linewidth=linewidth,
                         fill=fill, fillcolor=fillcolor, fillstyle=fillstyle,
                         fillsize=fillsize, fillskip=fillskip) 
        elif style == 'utriangle':
            self.polygon(coord=[[x-size,y+size],[x,y-size],[x+size,y+size]],
                         linecolor=linecolor, linewidth=linewidth, fill=fill,
                         fillcolor=fillcolor, fillstyle=fillstyle,
                         fillsize=fillsize, fillskip=fillskip) 
        elif style == 'plusline':
            self.line(coord=[[x-size,y],[x+size,y]], linecolor=linecolor,
                      linewidth=linewidth) 
            self.line(coord=[[x,y+size],[x,y-size]], linecolor=linecolor,
                      linewidth=linewidth) 
        elif style == 'xline':
            self.line(coord=[[x-size,y-size],[x+size,y+size]],
                      linecolor=linecolor, linewidth=linewidth) 
            self.line(coord=[[x-size,y+size],[x+size,y-size]],
                      linecolor=linecolor, linewidth=linewidth) 
        elif style == 'dline1':
            self.line(coord=[[x-size,y-size],[x+size,y+size]],
                      linecolor=linecolor, linewidth=linewidth) 
        elif style == 'dline2':
            self.line(coord=[[x-size,y+size],[x+size,y-size]],
                      linecolor=linecolor, linewidth=linewidth) 
        elif style == 'dline12':
            self.line(coord=[[x-size,y-size],[x+size,y+size]],
                      linecolor=linecolor, linewidth=linewidth) 
            self.line(coord=[[x-size,y+size],[x+size,y-size]],
                      linecolor=linecolor, linewidth=linewidth) 
        elif style == 'hline': 
            self.line(coord=[[x-size,y],[x+size,y]], linecolor=linecolor,
                      linewidth=linewidth, linedash=linedash)
        elif style == 'vline': 
            self.line(coord=[[x,y+size],[x,y-size]], linecolor=linecolor,
                      linewidth=linewidth)
        elif style == 'hvline':
            self.line(coord=[[x-size,y],[x+size,y]], linecolor=linecolor,
                      linewidth=linewidth) 
            self.line(coord=[[x,y+size],[x,y-size]], linecolor=linecolor,
                      linewidth=linewidth)
        elif style == 'diamond':
            self.polygon(coord=[[x-size,y],[x,y+size],[x+size,y],[x,y-size]], 
                         linecolor=linecolor, linewidth=linewidth, fill=fill,
                         fillcolor=fillcolor, fillstyle=fillstyle,
                         fillsize=fillsize, fillskip=fillskip) 
        elif style == 'star':
            s2 = size / 2.0
            xp  = s2 * math.cos(math.radians(18.0))
            yp  = s2 * math.sin(math.radians(18.0))
            xp2 = s2 * math.cos(math.radians(54.0))
            yp2 = s2 * math.sin(math.radians(54.0))
            self.polygon(coord=[[x,y+s2],[x+xp2,y-yp2],
                                [x-xp,y+yp],[x+xp,y+yp],
                                [x-xp2,y-yp2],[x,y+s2]],
                         linecolor=linecolor, linewidth=linewidth,
                         fill=fill, fillcolor=fillcolor, fillstyle=fillstyle,
                         fillsize=fillsize, fillskip=fillskip) 
        elif style == 'asterisk':
            self.line(coord=[[x-size,y-size],[x+size,y+size]],
                      linecolor=linecolor, linewidth=linewidth) 
            self.line(coord=[[x-size,y+size],[x+size,y-size]],
                      linecolor=linecolor, linewidth=linewidth)
            self.line(coord=[[x-size,y],[x+size,y]], linecolor=linecolor,
                      linewidth=linewidth) 
            self.line(coord=[[x,y+size],[x,y-size]], linecolor=linecolor,
                      linewidth=linewidth)
        else:
            abort('bad choice of point style: ' + style)
        return
    # END: shape()

    #
    # Internal routine to make patterns in shapes (like polygons, or circles)
    #
    def __make_pattern(self,
                       pattern_name = '',
                       coord        = [],
                       fillcolor    = 'black',
                       fillstyle    = 'solid',
                       fillsize     = 3,
                       fillskip     = 4,
                       ):
        drawer = self.drawer
        
        # bound box
        assert(len(coord) == 2)
        assert(len(coord[0]) == 2)
        assert(len(coord[1]) == 2)
        x1 = float(coord[0][0])
        y1 = float(coord[0][1])
        x2 = float(coord[1][0])
        y2 = float(coord[1][1])

        fillsize = float(fillsize)
        fillskip = float(fillskip)

        if fillstyle == 'solid':
            drawer.newpath()
            drawer.setlinewidth(0)
            drawer.rectangle(x1, y1, x2, y2)
            drawer.closepath()
            drawer.setfillcolor(fillcolor)
            drawer.setpattern(pattern_name)
            drawer.fill()
            drawer.stroke()
            return
            
        delta = 10
        if x2 > x1:
            x1 = x1 - delta
            x2 = x2 + delta
        else:
            nx1 = x2 - delta
            nx2 = x1 + delta
            x1  = nx1
            x2  = nx2

        if y2 > y1:
            y1 = y1 - delta
            y2 = y2 + delta
        else:
            ny1 = y2 - delta
            ny2 = y1 + delta
            y1  = ny1
            y2  = ny2

        # this is done for all except the solid ...
        style_list = ''

        if fillstyle == 'hline':
            style_list += 'hline '
            cy = y1
            while cy <= y2:
                drawer.newpath()
                drawer.setlinewidth(0)
                drawer.setfillcolor(fillcolor)
                drawer.rectangle(x1, cy, x2, cy + fillsize)
                drawer.closepath()
                drawer.fill()
                drawer.setpattern(pattern_name)
                drawer.stroke()
                cy = cy + fillsize + fillskip
        elif fillstyle == 'vline':
            style_list += 'vline '
            cx = x1
            while cx <= x2:
                drawer.newpath()
                drawer.setlinewidth(fillsize)
                drawer.setlinecolor(fillcolor)
                drawer.moveto(cx, y1)
                drawer.lineto(cx, y2)
                drawer.setpattern(pattern_name)
                drawer.stroke()
                cx = cx + fillsize + fillskip
        elif fillstyle == 'hvline':
            style_list += 'hvline '
            cy = y1
            while cy <= y2:
                drawer.newpath()
                drawer.setlinewidth(0)
                drawer.setfillcolor(fillcolor)
                drawer.rectangle(x1, cy, x2, cy + fillsize)
                drawer.closepath()
                drawer.fill()
                drawer.setpattern(pattern_name)
                drawer.stroke()
                cy = cy + fillsize + fillskip
            cx = x1
            while cx <= x2:
                drawer.newpath()
                drawer.setlinewidth(fillsize)
                drawer.setlinecolor(fillcolor)
                drawer.moveto(cx, y1)
                drawer.lineto(cx, y2)
                drawer.setpattern(pattern_name)
                drawer.stroke()
                cx = cx + fillsize + fillskip
        elif fillstyle == 'dline1':
            style_list += 'dline1 '
            cy = y1
            while cy <= y2:
                drawer.newpath()
                drawer.setlinecolor(fillcolor)
                drawer.setlinewidth(fillsize)
                drawer.moveto(x1, cy)
                drawer.lineto(x2, (x2-x1)+cy)
                drawer.setpattern(pattern_name)
                drawer.stroke()
                cy = cy + fillskip + fillsize
            cx = x1
            while cx <= x2:
                drawer.newpath()
                drawer.setlinecolor(fillcolor)
                drawer.setlinewidth(fillsize)
                drawer.moveto(cx, y1)
                drawer.lineto(cx+(y2-y1), y2)
                drawer.setpattern(pattern_name)
                drawer.stroke()
                cx = cx + fillskip + fillsize
        elif fillstyle == 'dline2':
            style_list += 'dline2 '
            cy = y1
            while cy <= y2:
                drawer.newpath()
                drawer.setlinecolor(fillcolor)
                drawer.setlinewidth(fillsize)
                drawer.moveto(x2, cy)
                drawer.lineto(x1, (x2-x1)+cy)
                drawer.setpattern(pattern_name)
                drawer.stroke()
                cy = cy + fillskip + fillsize
            cx = x2
            while cx >= x1:
                drawer.newpath()
                drawer.setlinecolor(fillcolor)
                drawer.setlinewidth(fillsize)
                drawer.moveto(cx, y1)
                drawer.lineto(cx-(y2-y1), y2)
                drawer.setpattern(pattern_name)
                drawer.stroke()
                cx = cx - (fillskip + fillsize)
        elif fillstyle == 'dline12':
            style_list += 'dline12 '
            cy = y1
            while cy <= y2:
                drawer.newpath()
                drawer.setlinewidth(fillsize)
                drawer.setlinecolor(fillcolor)
                drawer.moveto(x1, cy)
                drawer.lineto(x2, (x2-x1)+cy)
                drawer.setpattern(pattern_name)
                drawer.stroke()
                cy = cy + fillskip + fillsize
            cx = x1
            while cx <= x2:
                drawer.newpath()
                drawer.setlinewidth(fillsize)
                drawer.setlinecolor(fillcolor)
                drawer.moveto(cx, y1)
                drawer.lineto(cx+(y2-y1), y2)
                drawer.setpattern(pattern_name)
                drawer.stroke()
                cx = cx + fillskip + fillsize
            cy = y1
            while cy <= y2:
                drawer.newpath()
                drawer.setlinewidth(fillsize)
                drawer.setlinecolor(fillcolor)
                drawer.moveto(x2, cy)
                drawer.lineto(x1, (x2-x1)+cy)
                drawer.setpattern(pattern_name)
                drawer.stroke()
                cy = cy + fillskip + fillsize
            cx = x2
            while cx >= x1:
                drawer.newpath()
                drawer.setlinewidth(fillsize)
                drawer.setlinecolor(fillcolor)
                drawer.moveto(cx, y1)
                drawer.lineto(cx-(y2-y1), y2)
                drawer.setpattern(pattern_name)
                drawer.stroke()
                cx = cx - (fillskip + fillsize)
        elif fillstyle == 'circle':
            style_list += 'circle '
            cx = x1
            while cx <= x2:
                cy = y1
                while cy <= y2:
                    drawer.newpath('circle')
                    drawer.setfillcolor(fillcolor)
                    drawer.circle(cx, cy, fillsize)
                    drawer.fill()
                    drawer.setpattern(pattern_name)
                    drawer.stroke()
                    cy = cy + fillskip + fillsize
                cx = cx + fillsize + fillskip
        elif fillstyle == 'square':
            style_list += 'square '
            cx = x1
            while cx <= x2:
                cy = y1
                while cy <= y2:
                    drawer.newpath()
                    drawer.setlinewidth(0)
                    drawer.setlinecolor(fillcolor)
                    drawer.setfillcolor(fillcolor)
                    drawer.rectangle(cx, cy, cx+fillsize, cy+fillsize)
                    drawer.fill()
                    drawer.setpattern(pattern_name)
                    drawer.stroke()
                    cy = cy + fillskip + fillsize
                cx = cx + fillsize + fillskip
        elif fillstyle == 'triangle':
            style_list += 'triangle '
            cx = x1
            while cx <= x2:
                cy = y1
                while cy <= y2:
                    drawer.newpath()
                    drawer.setlinewidth(0)
                    drawer.setlinecolor(fillcolor)
                    drawer.setfillcolor(fillcolor)
                    drawer.moveto(cx-fillsize/2.0, cy)
                    drawer.lineto(cx+fillsize/2.0, cy)
                    drawer.lineto(cx, cy+fillsize)
                    drawer.closepath()
                    drawer.fill()
                    drawer.setpattern(pattern_name)
                    drawer.stroke()
                    cy = cy + fillskip + fillsize
                cx = cx + fillsize + fillskip
        elif fillstyle == 'utriangle':
            style_list += 'utriangle '
            cx = x1
            while cx <= x2:
                cy = y1
                while cy <= y2:
                    drawer.newpath()
                    drawer.setlinewidth(0)
                    drawer.setlinecolor(fillcolor)
                    drawer.setfillcolor(fillcolor)
                    drawer.moveto(cx-fillsize/2.0, cy+fillsize)
                    drawer.lineto(cx+fillsize/2.0, cy+fillsize)
                    drawer.lineto(cx, cy)
                    drawer.closepath()
                    drawer.fill()
                    drawer.setpattern(pattern_name)
                    drawer.stroke()
                    cy = cy + fillsize + fillsize
                cx = cx + fillsize + fillskip
        else:
            print('Bad fill style: [%s]' % fillstyle)
            abort('Should be one of %s' % style_list)
        return
    # END: makepattern()

    # 
    # --method-- text
    # 
    # Use this routine to place text on the canvas. Most options are obvious:
    # the expected coordinate pair, color, text, font, size - the size of the
    # font, rotation - which way the text should be rotated, but the anchor can
    # be a bit confusing. Basically, the anchor determines where, relative to
    # the coordinate pair (x,y), the text should be placed. Simple anchoring
    # includes left (l), center (c), or right (r), which determines whether the
    # text starts at the x position specified (left), ends at x (right), or is
    # centered on the x (center). Adding a second anchor (xanchor,yanchor)
    # specifies a y position anchoring as well. The three options there are low
    # (l), which is the default if none is specified, high (h), and middle (m),
    # again all determining the placement of the text relative to the y
    # coordinate specified.
    # 
    def text(self,
             # Coordinates for text on the canvas.
             coord    = [0,0],

             # Actual text to place on the canvas.
             text     = 'text',

             # Typeface to use.
             font     = 'default',

             # Color of letters.
             color    = 'black',

             # Font size.
             size     = 10,

             # Rotate text by this many degrees.
             rotate   = 0,

             # Anchor: can either just specify left/right
             # (e.g., 'c' for center, 'l' for left justify, 'r' for right)
             # or can also specify vertical alignment
             # (e.g., 'l,h' for left justify and high justify,
             # 'r,c' for right and center, 'l,l' for left and low).
             anchor   = 'c',

             # Background color behind text? Empty means no.
             bgcolor  = '',

             # Border (black) around background color?
             bgborder = 1,
             ):
        drawer = self.drawer
        
        x, y = coord[0], coord[1]

        asplit = anchor.split(',')
        if len(asplit) == 2:
            xanchor = asplit[0]
            yanchor = asplit[1]
        else:
            xanchor = anchor
            yanchor = 'l'

        # need width of string to adjust size based on anchor
        fontwidth = self.get_string_width(font, size, text)

        # adjust text placement based on anchors 
        dx, dy = 0, 0
        if xanchor == 'r':
            dx = -fontwidth
        elif xanchor == 'c':
            dx = -fontwidth / 2.0
        if yanchor == 'c':
            dy = -size * .36
        elif yanchor == 'h':
            dy = -size * .72

        # do background color first
        # (not implemented yet)

        # now just move to location and output text
        # rotation requires a little extra work ...
        self.drawer.begintext()
        if color != 'black':
            self.drawer.setfillcolor(color)
        self.drawer.setfont(font, size)
        self.drawer.showtext(text, x, y, dx, dy, xanchor, yanchor, rotate)
        drawer.endtext()
        return

    #
    # Internal routine to draw arrow head at end of line segment
    #
    def __arrowhead(self, coords, closepath, arrowheadlength, arrowheadwidth,
                    arrowlinecolor, arrowlinewidth, arrowfill, arrowfillcolor):
        c = len(coords)
        # start with last line segment of the line
        if closepath:
            sx, sy, fx, fy = coords[c-1][0], coords[c-1][1], coords[0][0], coords[0][1]
        else:
            sx, sy, fx, fy = coords[c-2][0], coords[c-2][1], coords[c-1][0], coords[c-1][1]
        xdiff, ydiff = float(fx) - float(sx), float(fy) - float(sy)
        # Now project a point out from the last point (fx,fy) to 'arrowheadlength' away
        angle = math.atan2(ydiff, xdiff)
        px, py = fx + arrowheadlength * math.cos(angle), \
                 fy + arrowheadlength * math.sin(angle)
        # now find other two points of arrowhead, by rotating 90 degrees both
        # ways and projecting it out from the final x,y points again
        angle_left  = angle + math.radians(90.0)
        angle_right = angle - math.radians(90.0)
        lx, ly = fx + (arrowheadwidth/2.0 * math.cos(angle_left)), \
                 fy + (arrowheadwidth/2.0 * math.sin(angle_left))
        rx, ry = fx + (arrowheadwidth/2.0 * math.cos(angle_right)), \
                 fy + (arrowheadwidth/2.0 * math.sin(angle_right))
        # with three points computed, can just draw a polygon to make the arrow
        self.polygon(coord=[[px, py], [lx, ly], [rx, ry]],
                     fill=arrowfill, fillcolor=arrowfillcolor,
                     linewidth=arrowlinewidth, linecolor=arrowlinecolor)
        return


    # 
    # --method-- line
    #
    # Use this to draw a line on the canvas.
    # 
    def line(self,
             # Coordinates of the line. A list of [x,y] pairs. Can
             # be as long as you like (not just two points).
             coord           = [[0,0],[0,0]],

             # Color of the line.
             linecolor       = 'black',

             # Width of the line.
             linewidth       = 1,

             # For turns in the line, how turn should be rounded.
             # Options include 0->'miter', 1->'round', 2->'bevel'.
             # Default is just do hard turns (miter).
             linejoin        = 0,

             # Shape used at end of line (0->'butt', 1->'round', 2->'square')
             linecap         = 0,

             # Dash pattern of the line. '0' means no dashes.
             # Otherwise, a list describing the on/off pattern
             # of the dashes, e.g., [2,2] means 2 on, 2 off, repeating.
             linedash        = 0,

             # Can use this to close the path (and perhaps fill it).
             # However, not really supported right now.
             closepath       = False,

             # Turn an arrow at last segment on or off.
             arrow           = False,

             # Length of arrow head.
             arrowheadlength = 4,

             # Width of arrow head.
             arrowheadwidth  = 3,

             # Color of arrow head line.
             arrowlinecolor  = 'black',

             # Width of line that makes arrow head.
             arrowlinewidth  = 0.5,

             # Fill arrow head with solid color?
             arrowfill       = True,

             # Color to fill arrow head with.
             arrowfillcolor  = 'black',

             # Style to use. 'normal' is one option. There are no others.
             arrowstyle      = 'normal',
            ):
        drawer = self.drawer

        drawer.gsave()
        drawer.newpath()

        if linecolor != 'black':
            drawer.setlinecolor(linecolor)
        if linewidth != 0:
            drawer.setlinewidth(linewidth)
        if linecap != 0:
            drawer.setlinecap(linecap)
        if linejoin != 0:
            drawer.setlinejoin(linejoin)
        if linedash != 0:
            drawer.setlinedash(linedash)

        point = coord[0]
        drawer.moveto(point[0], point[1])
        for i in range(1, len(coord)):
            point = coord[i]
            drawer.lineto(point[0], point[1])

        if closepath:
            drawer.closepath()
        drawer.stroke()
        drawer.grestore()

        if arrow:
            self.__arrowhead(coords=coord, closepath=closepath,
                             arrowheadlength=arrowheadlength,
                             arrowheadwidth=arrowheadwidth,
                             arrowlinecolor=arrowlinecolor,
                             arrowlinewidth=arrowlinewidth,
                             arrowfill=arrowfill,
                             arrowfillcolor=arrowfillcolor)
        return
    # END: line()

    # 
    # --method-- box
    #
    # Makes a box at coords specifying the bottom-left and upper-right corners.
    # Can change the width of the surrounding line (linewidth=0 removes it).
    # Can fill with solid or pattern. When filling with non-solid pattern, can
    # add a background color so as not to be see-through.
    # 
    def box(self,
            # Coordinates of box, from [x1,y1] to [x2,y2].
            coord       = [[0,0],[0,0]],

            # Color of lines that draws box.
            linecolor   = 'black',

            # Width of those lines. 0 means unlined box.
            linewidth   = 1,

            # Dash pattern in lines around box?
            linedash    = 0,

            # How should corners be done? 0 is default; 1->'round', 2->'bevel'.
            linecap     = 0,

            # For turns in the line, how turn should be rounded.
            # Options include 0->'miter', 1->'round', 2->'bevel'.
            # Default is just do hard turns (miter).
            linejoin    = 0,

            # Should box be filled? If so, specify here.
            fill        = False,

            # Color of the fill pattern.
            fillcolor   = 'black',

            # Type of fill pattern. Right now, all are 'solid'.
            fillstyle   = 'solid',

            # Details of fill pattern includes size of each marker in pattern.
            fillsize    = 3,

            # Also includes spacing between each marker in pattern.
            fillskip    = 4,

            # Rotate the box by this many degrees.
            rotate      = 0,

            # Put a background color behind the box. Useful when pattern has
            # see-through parts in it.
            bgcolor     = '',
            ):
        return self.polygon(coord=[[coord[0][0],coord[0][1]],
                                   [coord[0][0],coord[1][1]],
                                   [coord[1][0],coord[1][1]],
                                   [coord[1][0],coord[0][1]]],
                            linecolor=linecolor, linewidth=linewidth,
                            linecap=linecap, linejoin=linejoin,
                            linedash=linedash, fill=fill,
                            fillcolor=fillcolor, fillstyle=fillstyle,
                            fillsize=fillsize, fillskip=fillskip,
                            bgcolor=bgcolor)

    #
    # Internal routine used to actually draw a circle.
    # Based on cubic bezier curves.
    #
    def __circle(self, drawer, coord, radius, linecolor, linewidth, linedash,
                 fill, fillcolor, fillstyle, fillsize, fillskip, scale):
        xc, yc = coord[0], coord[1]
        radius = float(radius)

        drawer.gsave()
        drawer.newpath('circle')
        if linecolor != 'black':
            drawer.setlinecolor(linecolor)
        if linewidth != 0:
            drawer.setlinewidth(linewidth)
        if linedash != 0:
            drawer.setlinedash(linedash)
        if fill:
            drawer.setfillcolor(fillcolor)
        
        drawer.scale(scale[0], scale[1])
        drawer.circle(xc / scale[0], yc / scale[1], radius)
        
        if fill:
            drawer.fill()
        drawer.stroke()
        drawer.grestore()
        return

    # 
    # --method-- circle
    #
    # Can just make circles with this. Can fill them too. Exciting!
    #
    def circle(self,
               # Coordinates of center of circle in [x,y].
               coord     = [0,0],

               # Radius of circle.
               radius    = 1,

               # Scale in x direction and y direction, to make
               # an ellipse, for example.
               scale     = [1,1],

               # Color of lines of circle.
               linecolor = 'black',

               # Width of lines of circle.
               linewidth = 1,

               # Whether line is dashed or not.
               linedash  = 0,

               # Fill circle with colored pattern?
               fill      = False,

               # Which color?
               fillcolor = 'black',

               # Which pattern?
               fillstyle = 'solid',

               # Details of pattern: size of each marker.
               fillsize  = 3,

               # Details of pattern: space between each marker.
               fillskip  = 4,

               # Background color behind circle, useful if fill pattern
               # has some holes in it.
               bgcolor   = '',
               ):
        drawer = self.drawer
        if bgcolor != '' and fillstyle != 'solid':
            self.__circle(drawer, coord, radius, linecolor, 0, 0,
                          fill, bgcolor, 'solid', 0, 0, scale)
        if fill:
            if scale[0] != 1 or scale[1] != 1:
                print('warning: circle() filled pattern scaling not implemented')
            self.drawer.gsave()
            x, y = coord[0], coord[1]
            pattern_name = drawer.clipcircle(x, y, radius)
            self.__make_pattern(pattern_name=pattern_name,
                                coord=[[x-radius,y-radius],[x+radius,y+radius]],
                                fillcolor=fillcolor, fillstyle=fillstyle, fillsize=fillsize,
                                fillskip=fillskip)
            self.drawer.grestore()
        if linewidth != 0:
            self.__circle(drawer, coord, radius, linecolor, linewidth, linedash,
                          False, fillcolor, fillstyle, fillsize, fillskip, scale)
        return


    #
    # Internal routine to make a generic polygon
    #
    def __polygon(self, coord, linecolor, linewidth, linecap, linejoin, 
                  linedash, fill, fillcolor, fillstyle, fillsize, fillskip):
        drawer = self.drawer
        
        drawer.gsave()
        drawer.newpath()
        
        if linecolor != 'black':
            drawer.setlinecolor(linecolor)
        drawer.setlinewidth(linewidth)
        if linedash != 0:
            drawer.setlinedash(linedash)
        if linecap != 0:
            drawer.setlinecap(linecap)
        if linejoin != 0:
            drawer.setlinejoin(linejoin)
        if fill and fillcolor != 'black':
            drawer.setfillcolor(fillcolor)

        px, py = coord[0][0], coord[0][1]
        drawer.moveto(px, py)
        for p in range(1,len(coord)):
            drawer.lineto(coord[p][0], coord[p][1])
        drawer.closepath()

        if fill:
            drawer.fill()
        drawer.stroke()
        drawer.grestore()
        return

    #
    # --method-- polygon
    #
    # Use this method to make an arbitrary polygon, by passing in its
    # coordinates. All the usual arguments are specified.
    #
    #
    def polygon(self,
                # The list of [x,y] pairs that form the coordinates.
                coord      = [],

                # The color of the surrounding line (if width > 0).
                linecolor  = 'black',

                # The width of the line (0 for no line).
                linewidth  = 1,

                # The linecap.
                linecap    = 0,

                # The linejoin.
                linejoin   = 0,

                # The line dash pattern.
                linedash   = 0,

                # Fill the polygon?                
                fill       = False,

                # What color to fill it?
                fillcolor  = 'black',

                # What style to fill it with?
                fillstyle  = 'solid',

                # The fill size... 
                fillsize   = 3,

                # ...and the skip.
                fillskip   = 4,

                # A background color if there is no fill; useful
                # behind a pattern.
                bgcolor    = '',
                ):
        if bgcolor != '' and fillstyle != 'solid':
            self.__polygon(coord=coord, linecolor=linecolor, linewidth=linewidth,
                           linecap=linecap, linejoin=linejoin, linedash=linedash,
                           fill=True, fillcolor=bgcolor, fillstyle='solid',
                           fillsize=fillsize, fillskip=fillskip)
        if fill:
            if fillstyle == 'solid':
                self.__polygon(coord=coord, linecolor=linecolor,
                               linewidth=linewidth, linecap=linecap,
                               linejoin=linejoin, linedash=linedash,
                               fill=True, fillcolor=fillcolor,
                               fillstyle='solid', fillsize=fillsize,
                               fillskip=fillskip)
            else:
                self.drawer.gsave()
                pattern_name = self.drawer.clippoly(coord)

                # Find min and max of x, y;
                # doing so lets us make a pattern that covers the entire range.
                xmin, ymin = coord[0][0], coord[0][1]
                xmax, ymax = xmin, ymin
                for p in range(1, len(coord)):
                    if coord[p][0] < xmin: 
                        xmin = coord[p][0]
                    if coord[p][1] < ymin:
                        ymin = coord[p][1]
                    if coord[p][0] > xmax:
                        xmax = coord[p][0]
                    if coord[p][1] > ymax:
                        ymax = coord[p][1]

                self.__make_pattern(pattern_name=pattern_name, coord=[[xmin,ymin],[xmax,ymax]],
                                    fillcolor=fillcolor, fillstyle=fillstyle, fillsize=fillsize,
                                    fillskip=fillskip)
                self.drawer.grestore()
        if linewidth != 0:
            self.__polygon(coord=coord, linecolor=linecolor, linewidth=linewidth,
                           linecap=linecap, linejoin=linejoin, linedash=linedash,
                           fill=False, fillcolor='', fillstyle='', fillsize=0, fillskip=0)
        return
#END: class canvas        
        
#
# For backwards compatability, we provide these canvas-creation wrappers.
# (they used to be separate classes; now all handled by unified 'canvas' class)
# 
def postscript(title='default', dimensions=['3in','2in'],
               font='Helvetica', verbose=False, script=__file__):
    title_parts = title.split('.')
    return canvas(title_parts[1], title_parts[0], dimensions, font,
                  verbose, script)
    
def pdf(title='default', dimensions=['3in','2in'],
        font='Helvetica', verbose=False, script=__file__):
    title_parts = title.split('.')
    return canvas(title_parts[1], title_parts[0], dimensions, font,
                  verbose, script)
    
def svg(title='default', dimensions=['3in','2in'],
        font='Helvetica', verbose=False, script=__file__):
    title_parts = title.split('.')
    return canvas(title_parts[1], title_parts[0], dimensions, font,
                  verbose, script)
    

#
# --class-- drawable
# 
# Creates a drawable region onto which graphs can be drawn. Must define the
# xrange and yrange, which are each min,max pairs, so that the drawable can
# translate data in table into points on the graph. Also, must select which
# type of scale each axis is, e.g., linear, log10, and so forth. If unspecified,
# coordinates (the x,y location of the lower left of the drawable) and
# dimensions (the width, height of the drawable) will be guessed at; specifying
# these allows control over where and how big the drawable is. Other options do
# things like place a background color behind the entire drawable or make an
# outline around it.
# 
class drawable:
    def __init__(self,
                 # Canvas object upon which to draw.
                 canvas     = '',

                 # Dimensions of the drawable surface; e.g., ['1in','1in']. 
                 # If left as empty list, will make a guess as to size.
                 dimensions = [],

                 # Lower-left corner of drawable should be placed at this
                 # location on the canvas. If left as empty, will make a guess.
                 coord      = [],

                 # X range of the drawable.
                 xrange     = [],

                 # Y range of the drawable
                 yrange     = [],

                 # Scale to use ('linear' or 'log2' or 'log10' or 'logX')
                 # for x range; currently, no other types of scales supported.
                 xscale     = 'linear',

                 # Scale to use ('linear' or 'log2' or 'log10' or 'logX')
                 # for y range; currently, no other types of scales supported.
                 yscale     = 'linear',
                 ):
        # record canvas of this drawable...
        assert(canvas != '')
        self.canvas = canvas
        
        # check if x and y have been specified
        if coord == []:
            coord = ['0.5in', '0.5in']
        assert(len(coord) == 2)
        coord[0] = str(coord[0])
        coord[1] = str(coord[1])
        self.offset = [canvas.convert(coord[0]),
                       canvas.convert(coord[1])]

        # now, check if height and width have been specified
        if dimensions == []:
            dimensions = [canvas.width-float(self.offset[0])-15,
                          canvas.height-float(self.offset[1])-15]
        assert(len(dimensions) == 2)
        dimensions[0] = str(dimensions[0])
        dimensions[1] = str(dimensions[1])
        self.dimensions = [canvas.convert(dimensions[0]),
                           canvas.convert(dimensions[1])]

        self.scaletype = ['blank', 'blank']
        self.logbase = [0, 0]
        self.linearMin = [0, 0]
        self.linearMax = [0, 0]
        self.virtualMin = [0, 0]
        self.virtualMax = [0, 0]
        self.linearRange = [0, 0]

        for axis in ['x', 'y']:
            if axis == 'x':
                axisnum = 0
                gscale = xscale
                grange = xrange
            else:
                axisnum = 1
                gscale = yscale
                grange = yrange

            if gscale == 'linear':
                self.scaletype[axisnum]  = 'linear'
                self.linearMin[axisnum]  = float(grange[0])
                self.linearMax[axisnum]  = float(grange[1])
                self.virtualMin[axisnum] = float(grange[0])
                self.virtualMax[axisnum] = float(grange[1])

            else:
                idx = gscale.find('log')
                if idx == -1:
                    abort('must be a linear or log scale')
                tmp = gscale.split('log')
                assert(len(tmp) == 2)
                self.logbase[axisnum] = float(tmp[1])

                self.scaletype[axisnum]  = 'log'

                assert(float(grange[0]) > 0)
                assert(float(grange[1]) > 0)
                
                self.linearMin[axisnum]  = math.log(float(grange[0]),
                                                    self.logbase[axisnum])
                self.linearMax[axisnum]  = math.log(float(grange[1]),
                                                    self.logbase[axisnum])
                self.virtualMin[axisnum] = float(grange[0])
                self.virtualMax[axisnum] = float(grange[1])

            # and record the linear range (for use in scaling)
            self.linearRange[axisnum] = self.linearMax[axisnum] - \
                                        self.linearMin[axisnum]

        self.axismap = {'x': 0, 'y': 1}
        return
    # END: __init__

    # helper functions
    def __axisindex(self, axis):
        return self.axismap[axis]

    #
    # VALUES have three possible types
    #   Virtual    : what they are in the specifed scale type (log, linear)
    #   Linear     : what they are once the mapping has been applied
    #                (log(virtual), etc.)
    #   Scaled     : in Postscript points, scaled as if the drawable is at 0,0
    #   Translated : in Postscript points, scaled + offset of drawable
    #
    # How to go from one to the other?
    #   to translate from Virtual -> Linear, call [Map]
    #   to translate from Linear  -> Scaled, call [Scale]
    #   to translate from Scaled  -> Translated, call [Translate]
    # 
    def getscaletype(self, axis):
        axisnum = self.axismap[axis]
        return self.scaletype[axisnum]

    # Map: take value, map it onto a linear value scale
    def dmapNum(self, axisnum, value):
        scale = self.scaletype[axisnum]

        if scale == 'linear':
            return value
        elif scale == 'log':
            return math.log(value, self.logbase[axisnum])
        else:
            abort('unknown mapping scale')

    def scaleNum(self, axisnum, value):
        width  = self.dimensions[axisnum]
        lrange = self.linearRange[axisnum]
        result = float(value) * (width / lrange)
        return result
        
    # Scale: scale a linear value onto the drawable's range
    def scale(self, axis, value):
        return self.scaleNum(self.__axisindex(axis), value)

    # Translate: scale and then add the offset 
    def translate(self, axis, value):
        # need two linear values: then subtract, scale, and add offset
        anum  = self.__axisindex(axis)
        lmin  = self.linearMin[anum]
        value = self.dmapNum(anum, float(value))

        # offset + scaled difference = what we want
        result = self.offset[anum] + self.scaleNum(anum, value - lmin)
        return result

    # accessor function
    def virtualmin(self, axis):
        axisnum = self.axismap[axis]
        return self.virtualMin[axisnum]

    # accessor function
    def virtualmax(self, axis):
        axisnum = self.axismap[axis]
        return self.virtualMax[axisnum]

    def rangeiterator(self, axis, min, max, step):
        tlist = []
        axisnum = self.axismap[axis]
        scale = self.scaletype[axisnum]
        if scale == 'linear':
            i = min
            while i <= max:
                tlist.append(i)
                i = i + step
        elif scale == 'log':
            i = min
            while i <= max:
                tlist.append(i)
                i = i * step
        return tlist

    # useful for extracting canvas
    def canvas(self):
        return self.canvas

    #
    # --method-- map
    #
    # Can be used to map coordinates from something a drawable understands
    # to something that can be used on the canvas directly. Useful when placing
    # text or shapes on the canvas directly; pass d.map([x,y]) for example to
    # the coord= argument of a canvas direct draw function (such as text, line).
    #
    def map(self,
            # The coordinates to translate from the drawable coordinate system
            # to the canvas raw coordinates. Coordinates can be a single list
            # [x,y] or, for e.g. a line, a list of points [[x1,y1],[x2,y2]].
            coord=['',''],
            ):
        if type(coord) == list:
            # need to figure out: is this a simple list, or a list of lists?
            first = coord[0]
            if type(first) == list:
                return self.translatecoord(coord)
            else:
                return self.translatecoordsingle(coord)
        else:
            abort('map: needs to be passed a list')

    # useful for calling basic ps functions ...
    def translatecoord(self, coord):
        assert(coord != '')
        assert(len(coord) > 0)
        ucoord = []
        ucoord.append([self.translate('x', float(coord[0][0])),
                       self.translate('y', float(coord[0][1]))])
        for i in range(1,len(coord)):
            ucoord.append([self.translate('x', float(coord[i][0])),
                           self.translate('y', float(coord[i][1]))])
        return ucoord

    # useful for calling basic ps functions ...
    def translatecoordsingle(self, coord):
        assert(coord != '')
        assert(len(coord) > 0)
        ucoord = [self.translate('x', float(coord[0])),
                  self.translate('y', float(coord[1]))]
        return ucoord

    def getsize(self, axis):
        axisnum = self.axismap[axis]
        return self.dimensions[axisnum]

    def bottom(self):
        return self.offset[1]

    def top(self):
        return self.offset[1] + self.dimensions[1]

    def left(self):
        return self.offset[0]

    def right(self):
        return self.offset[0] + self.dimensions[0]
# END: class drawable

#
# --class-- table
#
# Tables store data to be plotted, and provide a thin layer over SQLite to
# select subsets of the data to plot. A table can be created and filled
# with contents of a file (the 'file' parameter) OR created and filled
# with data from another table (the 'table' parameter). When filling with
# data from a file, it is useful to pass in a 'separator' which tells the
# table class how the rows in the file are split. Default is whitespace.
#
class table:
    def __init__(self,
                 # File name where table should be populated from;
                 # file should have fixed number of columns of data.
                 file = '',

                 # If file name is not specified (as above), can populate
                 # a table with data from another table (this makes a copy).
                 table = '',

                 # When initializing a table from another table, use the
                 # 'where' option to perform a selection of which data you want.
                 # For example, 'where=c0 > 10' populates the new table with
                 # all rows where the first value in the row (i.e., c0) is
                 # greater than 10.
                 where = '',

                 # When reading from a file, use the 'separator' to split each
                 # line and thus decide the different entries for that line.
                 # Default is to use whitespace; a colon is a common one too.
                 separator = '',
                 ):
        self.file = file
        self.cnames = []

        data = []

        if table != '':
            rows = table.query(where)
            self.cnames  = table.cnames
            self.columns = table.columns
            self.file    = table.file

            for r in rows:
                element = []
                count = 0
                for i in r:
                    if count > 0:
                        element.append(i)
                    count = count + 1
                data.append(element)
            # generate unique name - undoubtedly not the way to do this.
            self.dbname = 'tmp' + str(random.randint(0,9999999))
        elif self.file != '':
            # first, look for schema
            fd = open(self.file, 'r')
            line = fd.readline().strip()
            if separator == '':
                separator = None
            tmp = line.split(separator)
            if (len(tmp) > 0) and (tmp[0] == '#'):
                # there is a schema, decode it
                self.columns = len(tmp)
                self.cnames.append('rownumber')
                for i in range(1, self.columns):
                    self.cnames.append(tmp[i].strip())
            else:
                # no schema: just assign column names c0, c1, etc.
                self.columns = len(tmp) + 1
                self.cnames.append('rownumber')
                for i in range(0, self.columns):
                    self.cnames.append('c'+str(i))
            fd.close()

            # open again for reading ...
            fd = open(self.file, 'r')
            for line in fd:
                line = line.strip()
                tmp = line.split(separator)
                if (len(tmp) > 0) and (tmp[0] != '') and (tmp[0][0] != '#'):
                    curlen = len(tmp)
                    if curlen != (self.columns - 1):
                        abort('Bad input row! (%s)' % line)
                    ntmp = []
                    for d in tmp:
                        ntmp.append(d.strip())
                    data.append(ntmp)
            fd.close()

            # extract unique number from file, somehow
            self.dbname = 'tmp' + str(random.randint(0,9999999))
        else:
            self.cnames  = ['rownumber']
            self.columns = 1
            self.file    = ''
            self.dbname = 'tmp' + str(random.randint(0,9999999))
        # END: if ...

        # make an in-memory database
        self.fd     = sqlite3.connect(':memory:')
        self.cursor = self.fd.cursor()

        # calling each column cXXX where XXX is the row number
        create = 'create table %s (' % self.dbname
        for i in range(0, self.columns):
            if i != 0:
                create += ', '
            create += '%s text' % self.cnames[i]
        create += ')'

        # create reverse index of column names
        self.rindex  = {}
        for i in range(0, self.columns):
            self.rindex[self.cnames[i]] = i
        self.cursor.execute(create)
        self.fd.commit()

        # now, insert values
        insert = 'insert into %s values (' % self.dbname
        for i in range(0, self.columns-1):
            insert = insert + '?, '
        insert = insert + '?)'

        count = 0
        for row in data:
            row.insert(0, count)
            count = count + 1
            self.cursor.execute(insert, row)
        return

    def __cnames(self):
        return self.cnames

    #
    # --method-- getaxislabels
    #
    # This method takes a column of data and returns it in a form
    # so you can directly pass it to the axis() class as either the
    # 'xmanual' or 'ymanual' parameter. Thus, you can call axis as
    # follows: axis(xmanual=t.getaxislabels('c0'), ...) to get the
    # values from column 'c0' of table 't' and use it to label the
    # x axis (in this example).
    #
    def getaxislabels(self,
                      # Which column to grab the data from.
                      column='',
                      ):
        self.cursor.execute('select * from %s' % (self.dbname))
        rindex = self.getrindex()
        idx    = rindex[column]
        cnt = 0
        rlist = []
        for row in self.cursor:
            tmp = []
            tmp.append(row[idx])
            tmp.append(cnt)
            rlist.append(tmp)
            cnt = cnt + 1
        return rlist

    #
    # --method-- dump
    #
    # Used to dump the contents of the table to stdout.
    #
    def dump(self,
             # A title to add to the output for clarity.
             title='',

             # Can add this to the output as well as a comment.
             canvas=None,
             ):
        s = ''
        if title:
            s += title + '\n'
        s += '*DUMP* '
        for name in self.cnames:
            s += name + ' '
        s += '\n'
        self.cursor.execute('select * from %s' % (self.dbname))
        for row in self.cursor:
            s += '*DUMP* ' + str(row) + '\n'
        if canvas:
            canvas.comment(s)
        else:
            print(s)
        return

    #
    # --method-- insert
    #
    # Allows SQL insert directly into a table.
    # SET column1=value, column2=value2,...
    # WHERE some_column=some_value
    # Format of keyValues should be ... XXX
    # 
    def insert(self,
               # Needs a better description.
               keyValues={},
               ):
        keys = sorted(keyValues.keys())
        values = ["'%s'" % keyValues[x] for x in keys]
        rownumber = self.cursor.execute('select count(*) from %s' % self.dbname)
        rownumber = rownumber.fetchone()[0] + 1
        query = ('insert into %s (rownumber, %s)'
                 'values (%d, %s)' % (
                self.dbname, ', '.join(keys), rownumber, ', '.join(values)))
        self.cursor.execute(query)
        return

    # 
    # --method-- update
    # 
    # Enables an update() of values in a column. Can use to sum
    # two columns, for example. 
    # 
    def update(self,
               # Specify how to set values in one column. Can just set a column
               # to a specific value (e.g., set='c0 = 100') or can do math 
               # across some columns (e.g., set='c0 = c0 + c1'). 
               set='',

               # Can operate on a subset of rows via selection.
               where='',
               ):
        assert(set != '')
        if where == '':
            self.cursor.execute('update %s set %s' % (self.dbname, set))
        else:
            self.cursor.execute('update %s set %s where %s' % (self.dbname, set,
                                                               where))
        return

    #
    # --method-- getmax
    #
    # Utility function to get maximum value of a particular column.
    #
    def getmax(self,
               # column to compute max over.
               column='',

               # If specified, only return value from column if it's
               # greater than 'cmax'. Otherwise, just return max.
               cmax='',
               ):
        if column == '':
            print('No column specified.')
        self.cursor.execute('select * from %s' % (self.dbname))
        rindex = self.getrindex()
        idx    = rindex[column]
        # print(column, idx)
        for row in self.cursor:
            value = float(row[idx])
            if cmax == '':
                cmax = value
            elif value > cmax:
                cmax = value
        return cmax

    #
    # --method-- getmin
    #
    # Returns min value over a given column.
    #
    def getmin(self,
               # Column to get data from.
               column='',

               # Only return values if they are less than cmin.
               # If not specified, just return min found.
               cmin='',
               ):
        if column == '':
            print('No column specified.')
            return 0
        self.cursor.execute('select * from %s' % (self.dbname))
        rindex = self.getrindex()
        idx    = rindex[column]
        for row in self.cursor:
            value = float(row[idx])
            if cmin == '':
                cmin = value
            if value < cmin:
                cmin = value
        return cmin

    #
    # --method-- getrange
    #
    # Gets the [min, max] of a column and returns it as a list.
    #
    def getrange(self,
                 # The column to perform min, max over.
                 column='',

                 # If not empty, 2-element list with min value
                 # and max value not to go below/exceed when looking
                 # for min and max in the column.
                 crange='',
                 ):
        if column == '':
            print('No column specified.')
            return [0, 0]
        if crange != '':
            return [self.getmin(column, crange[0]),
                    self.getmax(column, crange[1])]
        else:
            return [self.getmin(column, ''), self.getmax(column, '')]

    #
    # --method-- getvalues
    #
    # Returns values in a column as a list.
    #
    def getvalues(self,
                  # Column to get values of.
                  column='',
                  ):
        if column == '':
            print('No column specified.')
            return []
        self.cursor.execute('select * from %s' % (self.dbname))
        rindex = self.getrindex()
        idx    = rindex[column]
        # print(column, idx)
        return_values = []
        for row in self.cursor:
            return_values.append(row[idx])
        return return_values

    #
    # --method-- getavg
    #
    # Compute average over a column and return it.
    #
    def getavg(self,
               # Column over which to compute average.
               column='',

               # Where clause used to select subset of rows.
               where='',
               ):
        if column == '':
            print('Column not specified in call to getavg().')
            return 0
        if where == '':
            self.cursor.execute('select * from %s' % self.dbname)
        else:
            self.cursor.execute('select * from %s where %s' % (self.dbname,
                                                               where))

        rindex = self.getrindex()
        idx    = rindex[column]
        currsum = 0.0
        count   = 0
        for row in self.cursor:
            value   = float(row[idx])
            currsum = currsum + value
            count = count + 1
        if count > 0:
            return currsum / count
        else:
            return 0

    def getrindex(self):
        return self.rindex

    def getname(self):
        return self.dbname

    #
    # --method-- query
    #
    # Get data from table via a query.
    #
    def query(self,
              # Where clause to select which data to return.
              where='',

              # Which column to order the results by; '' -> don't order.
              order='',

              # * selects all columns, or you can pick a subset.
              select='*',

              # The group by clause also useful sometimes.
              group='',
              ):
        q = 'select %s from %s' % (select, self.dbname)
        if where != '':
            q += ' where %s' % where
        if order != '':
            q += ' order by %s' % order
        if group != '':
            q += ' group by %s' % group

        self.cursor.execute(q)

        # key: adding 'rownumber' as the first element of each row 
        results = []
        counter = 0
        for row in self.cursor:
            results.append(row)
            counter = counter + 1
        return results

    #
    # --method-- addcolumns
    #
    # Add a bunch of columns all at once. 
    #
    def addcolumns(self,
                   # columns to add to the table, all at once
                   columns=[],
                   ):
        for c in columns:
            self.addcolumn(column=c)
        return self

    #
    # --method-- addcolumn
    #
    # Add a column to the table, and initialize it with value.
    #
    def addcolumn(self,
                  # Column to be added.
                  column='',

                  # Value to initialize column to.
                  value='',
                  ):
        assert(column != '')
        self.cursor.execute('alter table %s add column %s text' % (self.dbname,
                                                                   column))
        self.cnames.append(column)
        self.rindex[column] = self.columns
        self.columns = self.columns + 1
        if value == '':
            value = 0
        self.cursor.execute('update %s set %s=\'%s\'' % (self.dbname, column,
                                                         value))
        return
# END: class table

# 
# --class-- plotter
#
# Use this to draw some points on a drawable. There are some obvious parameters:
# which drawable, which table, which x and y columns from the table to use, the
# color of the point, its linewidth, and the size of the marker. 'style' is a
# more interesting parameter, allowing one to pick a box, circle, horizontal
# line (hline), and 'x' that marks the spot, and so forth. However, if you set
# 'style' to label, PlotPoints will instead use a column from the table (as
# specified by the 'label' flag) to plot an arbitrary label at each (x,y) point.
# Virtually all the rest of the flags pertain to these text labels: whether to
# rotate them, how to anchor them, how to place them, font, size, and color.
# 
class plotter:
    def __init__(self,
                 # The default drawable for this plotter. However, you can
                 # specify a different drawable when making specific graphs
                 # (which thus overrides this default).
                 drawable='',
                 ):
        self.drawable = drawable
        return

    #
    # --method-- points
    #
    # Use this to draw points, as specified by x,y of a table, onto a drawable.
    # Basically, how you make a scatter plot is with the points() method.
    #
    def points(self,
               # Drawable object to place points onto.
               drawable        = '',

               # Table object to suck data from. 
               table           = '',

               # Where clause: which rows to plot? Default is all rows.
               where           = '',

               # Table column with x data.
               xfield          = 'c0',

               # Table column with y data.
               yfield          = 'c1',

               # Shift points in x,y direction by this amount.
               shift           = [0,0],

               # Size of each point; used unless sizefield is specified.
               size            = 2.0,       

               # Lots of styles available for these points, including:
               # label, hline, vline, plusline, xline, dline1, dline2, dline12,
               # square, circle, triangle, utriangle, diamond, star, asterisk.
               style           = 'xline',

               # If specified, table column with sizes for each point.
               # Allows point size to vary which is a nice feature.
               sizefield       = '',        

               # If using sizefield, use sizediv to scale each value (each 
               # sizefield gets divided by sizediv to get to the final size).
               sizediv         = '',        

               # Color of the line of the marker.
               linecolor       = 'black',

               # Width of lines used to draw marker.
               linewidth       = 1.0,

               # For some shapes, filling makes sense; if desired, mark True.
               fill            = False,

               # If filling, use this fill color. 
               fillcolor       = 'black',

               # If filling, which fill style: solid, hline, vline, hvline,
               # dline1, dline2, dline12, circle, square, triangle, utriangle.
               fillstyle       = 'solid',

               # Size of object in pattern.
               fillsize        = 3.0,

               # Space between object in pattern.
               fillskip        = 4.0,

               # If specified, table column with labels for each point.
               labelfield      = '',        

               # If specified, table column with labels for each point.
               labelformat     = '%s',      

               # If using labels, rotate labels by this many degrees.
               labelrotate     = 0,

               # If using labels, how to anchor them. 'x,y' where x can be
               # 'c' or 'l' or 'r' (for center, left, right) and y can be
               # 'c' or 'h' or 'l' for center, high, low).
               labelanchor     = 'c,c',

               # If using labels, place text: 'c' centered on point,
               # 's' below [south], 'n' above [north], 'e' east, 'w' west.
               labelplace      = 'c',

               # Shift text in label x,y direction
               labelshift      = [0,0],

               # If using labels, what font.
               labelfont       = 'default',

               # If using labels, fontsize for label.
               labelsize       = 6.0,

               # If using labels, what color font.
               labelcolor      = 'black',

               # If using labels, put a background color behind each.
               labelbgcolor    = '',        

               # Which legend object to use to add legend text to.
               legend          = '',

               # Text to add to legend.
               legendtext      = '',

               # Fields to add to yfield to determine y coord.
               # Can use this instead of table methods.
               stackfields     = [],        
               ):
        if drawable == '':
            drawable = self.drawable
        assert(drawable != '')
        canvas = drawable.canvas

        rindex = table.getrindex()
        xindex = rindex[xfield]
        yindex = rindex[yfield]
        if sizefield != '':
            sizeindex = rindex[sizefield]
        if labelfield != '':
            labelindex = rindex[labelfield]

        # iterate...
        for r in table.query(where):
            unscaledy = float(r[yindex])
            for stackfield in stackfields:
                unscaledy += float(r[rindex[stackfield]])

            x = drawable.translate('x', r[xindex])
            y = drawable.translate('y', unscaledy)

            if sizefield != '':
                # non-empty -> sizefield should be used (i.e., ignore use(size))
                size = float(r[sizeindex]) / float(sizediv)

            if style == 'label': 
                assert(labelfield != '')
                label = r[labelindex]
                if labelplace == 'c':
                    y = y + 0
                elif labelplace == 's':
                    y = y - labelsize
                elif labelplace == 'n':
                    y = y + labelsize
                elif labelplace == 'w':
                    x = x - size - 2.0
                elif labelplace == 'e':
                    x = x + size + 2.0
                else:
                    abort('bad place flag (%s); should be c, s, n, w, or e' % \
                          labelplace)
                text = labelformat % label
                canvas.text(coord=[x+labelshift[0],y+labelshift[1]], text=text,
                            anchor=labelanchor, rotate=labelrotate,
                            font=labelfont, size=labelsize, color=labelcolor,
                            bgcolor=labelbgcolor)
                
            else:
                canvas.shape(style=style, x=x+shift[0], y=y+shift[1], size=size,
                             linecolor=linecolor, linewidth=linewidth,
                             fill=fill, fillcolor=fillcolor,
                             fillstyle=fillstyle, fillsize=fillsize,
                             fillskip=fillskip)

        if legend != '':
            s = 'canvas.shape(style=\'' + style + \
                '\', x=$__Xx, y=$__Yy, size=$__M2, linecolor=\''+ \
                str(linecolor) + '\', linewidth=' + str(linewidth) + \
                ', fill=' + str(fill) + ', fillcolor=\'' + str(fillcolor) + \
                '\', fillstyle=\'' + str(fillstyle) + '\', fillsize=' + \
                str(fillsize) + ', fillskip=' + str(fillskip)+')'
            t = string.Template(s)
            legend.add(text=legendtext, picture=t)
        return
    # END: points()


    # 
    # --method-- horizontalbars
    # 
    # Use this to plot horizontal bars. The options are quite similar to the
    # vertical cousin of this routine, except (somehow) less feature-filled
    # (hint: lazy programmer).
    # 
    def horizontalbars(self,
                       # Drawable object on which to put the bars.
                       drawable    = '',

                       # Table from which to draw data.
                       table       = '',

                       # SQL select to subset the data as need be.
                       where       = '',

                       # Table column with x values.
                       xfield      = 'c0',

                       # Table column with y values.
                       yfield      = 'c1',

                       # If specified, table column with xlo data; use if bars
                       # don't start at the minimum of the range.
                       xloval      = '',

                       # Width of the bars.
                       barwidth    = 1.0,

                       # Color of the lines.
                       linecolor   = 'black',

                       # Width of the lines. 0 means no lines at all!
                       linewidth   = 1.0,

                       # Whether to fill each bar with some pattern.
                       fill        = False,

                       # Fill color for bars (if fill=True).
                       fillcolor   = 'black',

                       # Fill style for bars (if fill=True).
                       fillstyle   = 'solid',

                       # Fill size (if pattern has a marker of some size in it).
                       fillsize    = 3,

                       # Fill space between markers (if pattern has marker).
                       fillskip    = 4,

                       # Background color for bar - can make sense if pattern
                       # contains little markers, for example, because you can 
                       # use this to fill in a background color then.
                       bgcolor     = '',

                       # Legend object (if using a legend).
                       legend      = '',

                       # Text for legend.
                       legendtext  = '',

                       # Fields to add to yfield to determine y coord.
                       stackfields = [],       
                       ):
        if drawable == '':
            drawable = self.drawable
        assert(drawable != '')
        canvas = drawable.canvas
        assert(table != '')

        # construct query, adding fields as need be, and recording index values
        rindex = table.getrindex()
        xindex = rindex[xfield]
        yindex = rindex[yfield]

        for r in table.query(where):
            x = r[xindex]
            y = r[yindex]
            if xloval == '':
                # XXX: should be min of the yrange
                xlo = 0.0
            else:
                xlo = xloval

            if len(stackfields) > 0:
                xlo = 0
                for stackfield in stackfields:
                    inc = float(r[rindex[stackfield]])
                    xlo += inc
                    x = float(x)+inc

            bwidth = drawable.scale('y', barwidth)

            x1 = drawable.translate('x', xlo)
            y1 = drawable.translate('y', y) - (bwidth/2.0)
            x2 = drawable.translate('x', x)
            y2 = drawable.translate('y', y) + (bwidth/2.0)

            canvas.box(coord=[[x1,y1],[x2,y2]],
                       linecolor=linecolor, linewidth=linewidth, fill=fill,
                       fillcolor=fillcolor, fillstyle=fillstyle,
                       fillsize=fillsize, fillskip=fillskip, bgcolor=bgcolor)

        if legend != '':
            if fillcolor=='white' and linewidth==0:
                linewidth=1
            s = 'canvas.box(coord=[[$__Xmm,$__Ymm],[$__Xpm,$__Ypm]], fill=' + \
                str(fill) + ', fillcolor=\'' + str(fillcolor) + \
                '\', fillstyle=\'' + str(fillstyle) + '\', fillsize=\'' + \
                str(fillsize) + '\', fillskip=\'' + str(fillskip) + \
                '\', linewidth=\'' + str(linewidth/2.0) + '\', linecolor=\'' + \
                str(linecolor) + '\')'
            t = string.Template(s)
            legend.add(text=legendtext, picture=t)
        return
    # END: horizontalbars()

    #
    # helper function for vertical bars routine below
    # 
    def __getanchorplace(self, labelanchor, labelplace, y1, y2):
        if y2 < y1:
            # this is an upside down bar, so switch anchor and 'place'
            if labelplace == 'i':
                place = 3
            else:
                place = -3
        else:
            # normal bar (not upside down)
            if labelplace == 'i':
                place = -3
            else:
                place = 3

        if labelanchor == '':
            # autospecifying the anchor
            if place < 0:
                anchor = 'c,h'
            else:
                anchor = 'c,l'
        else:
            anchor = labelanchor
        return [anchor, place]

    #
    # --method-- verticalbars
    #
    # Use this to plot vertical bars on a drawable. A basic plot will specify
    # the table, xfield, and yfield. Bars will be drawn from the minimum of the
    # range to the y value found in the table. If the bars should start at some
    # value other than the minimum of the range (for example, when the yaxis
    # extends below zero, or you are building a stacked bar chart), two options
    # are available: ylofield and yloval. ylofield specifies a column of a
    # table that has the low values for each bar, i.e., a bar will be drawn at
    # the value specifed by the xfield starting at the ylofield value and going
    # up to the yfield value. yloval can be used instead when there is just a
    # single low value to draw all bars down to. Some other interesting options:
    # labelfield, which lets you add a label to each bar by giving a column of
    # labels (use rotate, anchor, place, font, fontsize, and fontcolor flags to
    # control details of the labels); barwidth, which determines how wide each
    # bar is in the units of the x-axis; linecolor, which determines the color
    # of the line surrounding the box, and linewidth, which determines its
    # thickness (or 0 to not have one); and of course the color and fill of the
    # bar, as determined by fillcolor, fillstyle, and fillsize and fillskip.
    # 
    def verticalbars(self,
                     # drawable to place vertical bars upon.
                     drawable      = '',

                     # table to get data from.
                     table         = '',

                     # SQL clause to subset some of the data
                     where         = '',

                     # xfield to use
                     xfield        = 'c0',

                     # yfield to use
                     yfield        = 'c1',

                     # if specified, table column with ylo data; use if bars
                     # don't start at the minimum of the range
                     ylofield      = '',        

                     # fields to add to yfield to determine y coord
                     stackfields     = [],

                     # if there is no ylofield, use this value to fill down to;
                     # if empty, just use min of yrange
                     yloval        = '',        

                     barwidth      = 1.0,       # bar width

                     # of the form n,m; thus, each x-axis data point actually
                     # will have 'm' bars plotted upon it; 'n' specifies which
                     # cluster of the 'm' this one is (from 0 to m-1); width of
                     # each bar is 'barwidth/m'; normal bar plots (without
                     # clusters) are just the default, '0,1'
                     cluster       = [0,1],

                     # color of the line surrounding each bar
                     linecolor     = 'black',

                     # width of the line; set to 0 if you don't want a
                     # surrounding line on the box
                     linewidth     = 0.25,

                     # fill the box or not 
                     fill          = False,

                     # fill color (if used)
                     fillcolor     = 'gray',

                     # solid, boxes, circles, ...
                     fillstyle     = 'solid',

                     # size of object in pattern
                     fillsize      = 3,

                     # space between object in pattern
                     fillskip      = 4,

                     # color background for the bar; empty means none (patterns
                     # may be see through)
                     bgcolor       = '',

                     # if specified, table column with labels for each bar
                     labelfield    = '',

                     # use this format for the labels; can prepend and postpend
                     # arbitrary text
                     labelformat   = '%s',

                     # rotate labels by this many degrees
                     labelrotate   = 0,

                     # text anchor if using a labelfield; empty means use a
                     # best guess
                     labelanchor   = '',

                     # place label (o) outside of bar or (i) inside of bar
                     labelplace    = 'o',

                     # shift text in x,y direction
                     labelshift    = [0.0,0.0],

                     # if using labels, what font should be used
                     labelfont     = 'default',

                     # if using labels, font for label
                     labelsize     = 10.0,

                     # if using labels, what color font should be used
                     labelcolor    = 'black',

                     # if specified, fill this color in behind each text item
                     labelbgcolor  = '',

                     # which legend?
                     legend        = '',

                     # text to add to legend
                     legendtext    = '',        
                     ):
        # start here
        if drawable == '':
            drawable = self.drawable
        assert(drawable != '')
        canvas = drawable.canvas

        assert(len(cluster) == 2)
        n        = float(cluster[0])
        clusters = float(cluster[1])
        assert(n >= 0)
        assert(n < clusters)

        barwidth  = drawable.scale('x', barwidth)
        ubarwidth = barwidth / clusters

        # construct query, adding fields as need be, and recording index values
        rindex = table.getrindex()
        xindex = rindex[xfield]
        yindex = rindex[yfield]
        if ylofield != '':
            yloindex = rindex[ylofield]
        if labelfield != '':
            labelindex = rindex[labelfield]

        # get data from table
        rows  = table.query(where)
        
        # if using loval (and not lofield)
        if yloval == '':
            ylo = drawable.virtualmin('y')
        else:
            ylo = yloval

        for r in rows:
            x = r[xindex]
            y = r[yindex]
            if ylofield != '':
                ylo = r[yloindex]

            if len(stackfields) > 0:
                ylo = 0
                for stackfield in stackfields:
                    inc = float(r[rindex[stackfield]])
                    ylo += inc
                    y = float(y)+inc

            x1 = drawable.translate('x', x) - (barwidth/2.0) + (ubarwidth * n)
            y1 = drawable.translate('y', ylo)
            x2 = x1 + ubarwidth
            y2 = drawable.translate('y', y)

            # auto set anchor, etc.
            ap = self.__getanchorplace(labelanchor, labelplace, y1, y2)
            anchor = ap[0]
            place  = ap[1]

            # make the arg list and call the box routine
            canvas.box(coord=[[x1,y1],[x2,y2]],
                       linecolor=linecolor, linewidth=linewidth, fill=fill,
                       fillcolor=fillcolor, fillstyle=fillstyle,
                       fillsize=fillsize, fillskip=fillskip, bgcolor=bgcolor)

            if labelfield != '':
                label  = labelformat % r[labelindex]
                xlabel = x1 + ubarwidth/2.0 + labelshift[0]
                ylabel = drawable.translate('y', y) + place + labelshift[1]
                canvas.text(coord=[xlabel,ylabel], text=label, anchor=anchor,
                            rotate=labelrotate, font=labelfont, size=labelsize,
                            color=labelcolor, bgcolor=labelbgcolor)

        if legend != '':
            if fillcolor=='white' and linewidth==0:
                linewidth=1
            s = 'canvas.box(coord=[[$__Xmm,$__Ymm],[$__Xpm,$__Ypm]], fill=' + \
                str(fill) + ', fillcolor=\'' + str(fillcolor) + \
                '\', fillstyle=\'' + str(fillstyle) + '\', fillsize=\'' + \
                str(fillsize) + '\', fillskip=\'' + str(fillskip) + \
                '\', linewidth=\'' + str(linewidth/2.0) + '\', linecolor=\'' + \
                str(linecolor) + '\')'
            t = string.Template(s)
            legend.add(text=legendtext, picture=t)
        return
    # END: verticalbars()

    #
    # --method-- line
    # 
    # Use this function to plot lines. It is one of the simplest routines there
    # is -- basically, it takes the x and y fields and plots a line thru them.
    # It does NOT sort them, though, so you might need to do that first if you
    # want the line to look pretty. The usual line arguments can be used,
    # including color, width, and dash pattern.
    # 
    def line(self,
             # Drawable object to place points onto.
             drawable     = '',

             # Table object to suck data from. 
             table        = '', 

             # Where clause: which rows to plot? Default is all rows.
             where        = '', 

             # Table column with x data.
             xfield       = 'c0', 

             # Table column with y data.
             yfield       = 'c1',

             # plot the data in a stairstep manner (e.g., CDF) if this is True
             stairstep    = False,

             # color of line.
             linecolor    = 'black',

             # width of line.
             linewidth    = 1.0,

             # specifies "linejoin".
             # Options include 0->'miter', 1->'round', 2->'bevel'
             # Default is miter
             linejoin     = 0,

             # Shape used at end of line (0->'butt', 1->'round', 2->'square')
             linecap      = 0,

             # dash pattern - 0 means no dashes.
             # [2,2] means line of 2, space of 2
             linedash     = 0,

             # if specified, table column with labels for each point in line.
             # Rest of label args spec things about the lables.
             labelfield   = '',      

             # which direction from point to place label. n->north, etc.
             labelplace   = 'n',

             # which font to use
             labelfont    = 'default',

             # size of text for labels.
             labelsize    = 8.0,

             # color of label text.
             labelcolor   = 'black',

             # how to anchor the text relative to the point.
             labelanchor  = 'c',

             # angle (degrees) to rotate text.
             labelrotate  = 0,

             # shift the labels by [x,y]
             labelshift   = [0,0],

             # format string to use for labels
             labelformat  = '%s',

             # put a box of color behind each label
             labelbgcolor = '',
             
             # if using labels, how much to offset from point by
             labeloffset  = 3.0,

             # legend object to use for this; '' means none.
             legend       = '',

             # text to associate with this specific line in legend.
             legendtext   = '',       

             # if adding points as well - a convenience?
             symbstyle    = '',
             symbsize     = 2,
             symbfill     = False,
             ):

        if drawable == '':
            drawable = self.drawable
        assert(drawable != '')

        if symbstyle:
            self.points(drawable=drawable, table=table, style=symbstyle,
                        xfield=xfield, yfield=yfield, size=symbsize,
                        fill=symbfill, linecolor=linecolor, fillcolor=linecolor)

        # get some things straight before looping
        if labelplace == 'n':
            offset = labeloffset
        elif labelplace == 's':
            offset = -labeloffset

        assert(table != '')

        # construct query, adding fields as need be, and recording index values
        rindex = table.getrindex()
        xindex = rindex[xfield]
        yindex = rindex[yfield]
        if labelfield != '':
            labelindex = rindex[labelfield]

        # get data from table
        rows  = table.query(where)

        lastx = -1
        lasty = -1

        linelist = []

        canvas = drawable.canvas

        x = 0
        lastyt = 0

        for r in rows:
            x = r[xindex]
            y = r[yindex]

            if labelfield != '':
                label = r[labelindex]

            xt = drawable.translate('x', x)
            yt = drawable.translate('y', y)

            if len(linelist) > 0 and stairstep == True:
                linelist.append([xt, lastyt])
            linelist.append([xt, yt])
            lastyt = yt 

            if labelfield != '':
                label  = labelformat % r[labelindex]
                xlabel = xt + labelshift[0]
                ylabel = yt + labelshift[1] + offset
                canvas.text(coord=[xlabel,ylabel], text=label,
                            anchor=labelanchor, rotate=labelrotate,
                            font=labelfont, size=labelsize,
                            color=labelcolor, bgcolor=labelbgcolor)
        # end: for r in rows
        # if stairstep == True:
        # should this really just be one? what if each stairstep
        # is much bigger than that? what should it be then?
        # XXX
        # linelist.append([drawable.translate('x', float(x) + 1.0), lastyt])

        canvas.line(coord=linelist, linecolor=linecolor, linewidth=linewidth,
                    linedash=linedash, linecap=linecap, linejoin=linejoin)

        if legend != '':
            s = 'canvas.shape(style=\'hline\', x=$__Xx, y=$__Yy, size=$__M2,' \
                + 'linecolor=\'' + str(linecolor) + '\', linewidth=' + \
                str(linewidth) + ', linedash=' + str(linedash) + ')'
            t = string.Template(s)
            legend.add(text=legendtext, picture=t)

        return
    # END: line()

    #
    # --method-- function
    #
    # Use function() to plot a function right onto a drawable. The function
    # should simply take one argument (e.g., x) and return the value of the
    # function (e.g., f(x)).
    # 
    def function(self,
                 # drawable to place function upon.
                 drawable   = '',

                 # the function, such as 'x*x' or 'x' or '3*x + 10', etc.
                 function   = '',
                 
                 # the x-range the function should be plotted over [xmin,xmax]
                 xrange     = [0,10],

                 # given the range of xmin to xmax, step determines at which x
                 # values the function is evaluated and a line is drawn to
                 step       = 1,

                 # if given, limit function to values between low/hi y values
                 ylimit     = ['',''],

                 # line width
                 linewidth  = 1,

                 # line color
                 linecolor  = 'black',

                 # dash pattern; 0 for none.
                 linedash   = 0,

                 # legend object
                 legend     = '',

                 # text to associate with this line.
                 legendtext = '',     
                 ):
        if drawable == '':
            drawable = self.drawable
        assert(drawable != '')
        linelist = []
        x = xrange[0]
        while x <= xrange[1]:
            y = function(x)
            if ((ylimit[0] == '') or (ylimit[0] != '') and (y >= ylimit[0])) \
                   and ((ylimit[1] == '') or ((ylimit[1] != '') and \
                                              (y <= ylimit[1]))):
                linelist.append([drawable.translate('x', x),
                                 drawable.translate('y', y)])
            x = x + step
            
        canvas = drawable.canvas
        canvas.line(coord=linelist, linecolor=linecolor, linewidth=linewidth,
                    linedash=linedash)

        if legend != '':
            s = 'canvas.line(coord=[[$__Xmw,$__Yy],[$__Xpw,$__Yy]], ' + \
                'linewidth=%s, linecolor=\'%s\', linedash=%s)' % \
                (linewidth, linecolor, linedash)
            t = string.Template(s)
            legend.add(text=legendtext, picture=t)

        return
    # END: function()

    # 
    # --method-- horizontalintervals
    #
    # Use this to plot interval markers in the x direction. The y column has
    # the y value for each interval, and draws the interval between the ylo and
    # yhi column values. The marker can take on many forms, as specified by
    # the 'align' flag. Note the 'b' type in particular, which can be used to
    # assemble box plots.
    #
    def horizontalintervals(self,
                            # drawable object
                            drawable  = '',

                            # table object with data
                            table     = '',

                            # select a subset of the table?
                            where     = '',

                            # table column with y data
                            yfield    = '',

                            # table column with xlo data
                            xlofield  = '',

                            # table column with xhi data
                            xhifield  = '',

                            # c-center u-upper l-lower n-none
                            align     = 'c',

                            # color of the line
                            linecolor = 'black',

                            # width of all lines
                            linewidth = 1,

                            # width of interval marker on top
                            devwidth  = 3,  
                            ):
        if drawable == '':
            drawable = self.drawable
        assert(drawable != '')
        canvas = drawable.canvas

        rindex   = table.getrindex()
        yindex   = rindex[yfield]
        xloindex = rindex[xlofield]
        xhiindex = rindex[xhifield]

        # get data from table
        rows  = table.query(where)

        for r in rows:
            y   = r[yindex]
            xlo = r[xloindex]
            xhi = r[xhiindex]

            yp   = drawable.translate('y', y)
            xlop = drawable.translate('x', xlo)
            xhip = drawable.translate('x', xhi)

            dw   = devwidth / 2.0
            hlw  = linewidth / 2.0
            
            if align == 'c':
                canvas.line(coord=[[xlop,yp],[xhip,yp]], linecolor=linecolor,
                            linewidth=linewidth)
            elif align == 'l':
                canvas.line(coord=[[xlop,yp-dw+hlw],[xhip,yp-dw+hlw]],
                            linecolor=linecolor, linewidth=linewidth)
            elif align == 'u':
                canvas.line(coord=[[xlop,yp+dw-hlw],[xhip,yp+dw-hlw]],
                            linecolor=linecolor, linewidth=linewidth)
            elif align != 'n':
                abort('Bad alignment: %s; should be c, l, or r' % align)

            # vertical line between two end marks
            canvas.line(coord=[[xhip,yp-dw],[xhip,yp+dw]], linecolor=linecolor,
                        linewidth=linewidth)
            canvas.line(coord=[[xlop,yp-dw],[xlop,yp+dw]], linecolor=linecolor,
                        linewidth=linewidth)
        return
    # END: horizontalintervals()

    # 
    # --method-- verticalintervals
    # 
    # Use this to plot interval markers in the y direction. The x column has
    # the x value for each interval, and draws the interval between the ylo and
    # yhi column values. The marker can take on many forms, as specified by
    # the 'align' flag. Note the 'b' type in particular, which can be used to
    # assemble box plots. 
    # 
    def verticalintervals(self,
                          drawable    = '',   # name of the drawable area
                          table       = '',   # name of table to use
                          where       = '',   # where clause?
                          xfield      = 'c0', # table column with x data
                          ylofield    = 'c1', # table column with ylo data
                          yhifield    = 'c2', # table column with yhi data
                          align       = 'c',  # c-center l-left r-right n-none
                          linecolor   = 'black', # color of the line
                          linewidth   = 1,    # width of all lines
                          devwidth    = 3,    # width of interval marker on top
                          ):
        if drawable == '':
            drawable = self.drawable
        assert(drawable != '')
        canvas = drawable.canvas

        # construct query, adding fields as need be, and recording index values
        rindex   = table.getrindex()
        xindex   = rindex[xfield]
        yloindex = rindex[ylofield]
        yhiindex = rindex[yhifield]

        # get data from table
        rows  = table.query(where)

        for r in rows:
            x   = r[xindex]
            ylo = r[yloindex]
            yhi = r[yhiindex]

            xp   = drawable.translate('x', x)
            ylop = drawable.translate('y', ylo)
            yhip = drawable.translate('y', yhi)

            dw   = devwidth / 2.0
            hlw  = linewidth / 2.0

            if align == 'c':
                canvas.line(coord=[[xp,ylop],[xp,yhip]], linecolor=linecolor,
                            linewidth=linewidth)
            elif align == 'l':
                canvas.line(coord=[[xp-dw+hlw,ylop],[xp-dw+hlw,yhip]],
                            linecolor=linecolor, linewidth=linewidth)
            elif align == 'r':
                canvas.line(coord=[[xp+dw-hlw,ylop],[xp+dw-hlw,yhip]],
                            linecolor=linecolor, linewidth=linewidth)
            elif align != 'n':
                # n is the only other reasonable choice...
                abort('Bad alignment (%s): should be c, l, r, or n' % align)

            # vertical line between two end marks
            canvas.line(coord=[[xp-dw,yhip],[xp+dw,yhip]], linecolor=linecolor,
                        linewidth=linewidth)
            canvas.line(coord=[[xp-dw,ylop],[xp+dw,ylop]], linecolor=linecolor,
                        linewidth=linewidth)
        return
    # END: verticalintervals()

    #
    # --method-- verticalfill
    #
    # Use this function to fill a vertical region between either the values in
    # yfield and the minimum of the y-range (default), the yfield values and
    # the values in the ylofield, or the yfield values and a single yloval.
    # Any pattern and color combination can be used to fill the filled space.
    # 
    def verticalfill(self,
                     # the drawable object
                     drawable   = '',

                     # table object
                     table      = '',

                     # where clause to select subset of data if need be
                     where      = '',

                     # table column with x data
                     xfield     = '',

                     # table column with y data
                     yfield     = '',

                     # if not empty, fill down to this column value
                     ylofield   = '',  

                     # if no ylofield, use this value to fill down to;
                     # if empty, use min of y-range
                     yloval     = '',  

                     # use stairsteps in making fill
                     stairstep  = False,

                     #  fill color (if used)
                     fillcolor  = 'lightgrey',

                     # solid, boxes, circles, ...
                     fillstyle  = 'solid',

                     # size of object in pattern
                     fillsize   = 3,

                     # space between object in pattern
                     fillskip   = 4,

                     # which legend object?
                     legend     = '',

                     # text to add to legend
                     legendtext = '',  
                     ):
        if drawable == '':
            drawable = self.drawable
        assert(drawable != '')

        # get rindex
        rindex   = table.getrindex()
        xindex   = rindex[xfield]
        yindex   = rindex[yfield]
        if ylofield != '':
            yloindex = rindex[ylofield]
        else:
            if yloval == '':
                ylo = drawable.translate('y', 0.0)
            else:
                ylo = drawable.translate('y', yloval)

        canvas = drawable.canvas

        first = 0
        for r in table.query(where):
            # get first point
            x = drawable.translate('x', r[xindex])
            y = drawable.translate('y', r[yindex])
            if ylofield != '':
                ylo = drawable.translate('y', r[yloindex])

            if first == 0:
                xlast   = x
                ylast   = y
                ylolast = ylo
                first   = 1
            else:
                xcurr   = x
                ycurr   = y
                ylocurr = ylo

                # draw the polygon between the last pair of points and
                # the current points if stairstep is in action
                if stairstep:
                    ycurr_use   = ylast
                    ylocurr_use = ylolast
                else:
                    ycurr_use   = ycurr
                    ylocurr_use = ylocurr

                canvas.polygon(coord=[[xlast,ylolast],[xlast,ylast],
                                      [xcurr,ycurr_use],[xcurr,ylocurr_use]],
                               fill=True, fillcolor=fillcolor,
                               fillstyle=fillstyle, fillsize=fillsize,
                               fillskip=fillskip, linewidth=0.1,
                               linecolor=fillcolor)
                # future: 
                # make a little bit of linewidth so as to overlap
                # neighboring regions. The alternate is worse: having to draw
                # one huge polygon (though maybe not that bad...)

                # move last points to current points
                xlast   = xcurr
                ylast   = ycurr
                ylolast = ylocurr
        # END: for ...

        if legend != '':
            s = 'canvas.shape(style=\'' + 'square' + \
                '\', x=$__Xx, y=$__Yy, size=$__M2, linecolor=\''+ \
                'black' + '\', linewidth=' + str(0.5) + \
                ', fill=' + str(True) + ', fillcolor=\'' + str(fillcolor) + \
                '\', fillstyle=\'' + str(fillstyle) + '\', fillsize=' + \
                str(fillsize) + ', fillskip=' + str(fillskip)+')'
            t = string.Template(s)
            legend.add(text=legendtext, picture=t)
        return
    # END: verticalfill()

    # --method-- heat
    #
    # Use this to plot a heat map. A heat map takes x,y,heat triples and
    # plots a gray-shaded box with darkness proportional to (heat/divisor)
    # and of size (width by height) at each (x,y) coordinate.
    # 
    def heat(self,
             # drawable object 
             drawable = '',

             # name of table to use
             table = '',

             # subset of table via query?
             where = '',

             # table column with x data
             xfield = 'c0',

             # table column with y data
             yfield = 'c1',

             # table column with heat data
             hfield = 'heat',

             # width of each rectangle
             width = 1,

             # height of each rectangle
             height = 1,

             # how much to divide heat value by
             divisor = 1.0,

             # if true, add labels to each heat region reflecting count value
             label = False,

             # if using labels, what font should be used
             labelfont = 'default', 

             # if using labels, what color is the font
             labelcolor = 'orange',

             # if using labels, what font size should be used
             labelsize = 6.0,

             # if using labels, what should the format be
             labelformat = '%.2f', 
             ):
        # get rindex
        rindex = table.getrindex()
        xindex = rindex[xfield]
        yindex = rindex[yfield]
        hindex = rindex[hfield]

        canvas = drawable.canvas

        for r in table.query(where):
            tx = drawable.translate('x', r[xindex])
            ty = drawable.translate('y', r[yindex])
            h = float(r[hindex])

            heat = h / divisor

            w = drawable.scale('x', width)
            h = drawable.scale('y', height)

            # absence of color is black (0,0,0)
            scolor = 1.0 - heat
            color = canvas.getcolor('%s,%s,%s' % (scolor, scolor, scolor))

            canvas.box(coord=[[tx,ty],[tx+w, ty+w]], linewidth=0, fill=True,
                       fillcolor=color, fillstyle='solid')
        return
    # END heat()
    
# END: class plotter

#
# --class-- axis
#
# Use this to draw some axes. There are a huge number of options. A first
# decision might be which 'style' to use: 'x' (x axis only), 'y' (y axis),
# 'xy' (for x and y axes), and 'box' to put a box around the entire thing.
# Making multiple axes is nice if you have, for example, two y axes for
# different data sets plotting onto the same drawable.
# 
class axis:
    def __init__(self,
                 # The drawable object upon which to draw this axis.
                 drawable      = '',

                 # The color of axis line.
                 linecolor     = 'black',

                 # The width of axis line.
                 linewidth     = 1.0,       

                 # dash parameters; will make axes dashed, but not tic marks.
                 # 0 means no dashes; otherwise use a list to specify the
                 # dash pattern (e.g., [2,2], or [2,3,2], etc.).
                 linedash      = 0,

                 # Which axes to draw: 'xy', 'x', 'y', 'box' are the options.
                 style         = 'xy',

                 # Labels 'in' or 'out'? for xaxis, 'out' means below and
                 # 'in' above; for yaxis,'out' means left/'in' right
                 labelstyle    = 'out',

                 # Are tics 'in', 'out', or 'centered'? (inside the axes,
                 # outside them, or centered upon the axes)
                 ticstyle      = 'out',

                 # Whether to draw the actual axes or not; useful if you just
                 # want to draw the tic marks, for example.
                 doaxis        = True,

                 # Whether to put labels on or not.
                 dolabels      = True,

                 # Whether to put majortics on axes or not.
                 domajortics   = True,

                 # Whether to put major tics on x-axis.
                 doxmajortics  = True,

                 # Whether to put major tics on y-axis.
                 doymajortics  = True,

                 # Whether to put minortics on axes or not.
                 dominortics   = False,

                 # Whether to put major tics on x-axis.
                 doxminortics  = True,

                 # Whether to put major tics on y-axis.
                 doyminortics  = True,

                 # Whether to put labels on x-axis.
                 doxlabels     = True,

                 # Whether to put labels on y-axis.
                 doylabels     = True,      

                 # The min/max values to draw xaxis between; empty (default)
                 # means the whole range.
                 xaxisrange    = '',

                 # The min/max values to draw yaxis between; empty (default)
                 # means the whole range.
                 yaxisrange    = '',

                 # The y value that the x-axis is located at; empty gives you
                 # the min; ignored by 'box'.
                 xaxisposition = '',

                 # The x value that the y-axis is located at; empty gives you
                 # the min; ignored by 'box'.
                 yaxisposition = '',        

                 # [x1,x2,step] will put labels and major tics from 'x1' to 'x2'
                 # with 'step' between each; can leave any of these empty ('')
                 # and the method will fill in a guess (either the min or max 
                 # of range, or a guess for the step), e.g., [0,'',2] means
                 # start at 0, fill in the max of the xrange for a max value,
                 # and set the step to 2. The default is to guess these values.
                 xauto         = ['','',''],

                 # Specify labels/majortics by hand with a list of form:
                 # [['label1', x1], ['label2', x2]...]. Can also be filled in
                 # from a table column with method table.getaxislabels(column=).
                 xmanual       = '',        

                 # Similar to xauto, but for the y-axis.
                 yauto         = ['','',''],

                 # Similar to xmanual, but for y-axis.
                 ymanual       = '',        

                 # Size of the major tics.
                 ticmajorsize  = 4.0,

                 # Size of the minor tics.
                 ticminorsize  = 2.5,       

                 # how many minor tics between each major tic (x axis)
                 xminorticcnt  = 1,

                 # how many minor tics between each major tic (y axis)
                 yminorticcnt  = 1,         

                 # Font to use for x labels.
                 xlabelfont      = 'default',

                 # font size of labels for x labels.
                 xlabelfontsize  = 10.0,

                 # font color for x labels.
                 xlabelfontcolor = 'black',

                 # Rotation for x labels, in degrees. If not 0, 90 is common.
                 xlabelrotate   = 0,          

                 # If non-empty, put a background colored square behind xlabels.
                 xlabelbgcolor = '',
                 
                 # Text anchor for labels along the x axis; empty means guess.
                 xlabelanchor   = '',

                 # Format string for xlabels; e.g., %d for ints; empty (default)
                 # implies best guess; can also use this to add decoration to
                 # the label, e.g., '%i %%' will add a percent sign to each
                 # integer label, and so forth.
                 xlabelformat   = '',         

                 # Font to use for y labels.
                 ylabelfont      = 'default',

                 # font size of labels for y labels.
                 ylabelfontsize  = 10.0,

                 # font color for y labels.
                 ylabelfontcolor = 'black',

                 # Rotation for x labels, in degrees. If not 0, 90 is common.
                 ylabelrotate   = 0,          

                 # If non-empty, put a background colored square behind ylabels.
                 ylabelbgcolor = '',
                 
                 # Text anchor for labels along the x axis; empty means guess.
                 ylabelanchor   = '',

                 # Format string for y labels; see xlabelformat for details.
                 ylabelformat   = '',         

                 # What to multiply xlabel values by; e.g., if 10, 1 becomes 10,
                 # 2 becomes 20, and so forth.
                 xlabeltimes   = 1,
                 
                 # Similar to xlabeltimes, but for y label values.
                 ylabeltimes   = 1,           

                 # Shift xlabels left/right, up/down (+4,-3 -> right 4, down 3)
                 xlabelshift   = [0,0],
                 
                 # Similar to xshift, but for ylabels.
                 ylabelshift   = [0,0],       

                 # Title along the X axis.
                 xtitle        = '',

                 # Font to use for x title.
                 xtitlefont    = 'default',

                 # Font size for x title.
                 xtitlesize    = 10,

                 # Font color for xtitle.
                 xtitlecolor   = 'black',

                 # General placement of xtitle:
                 # 'c' for center, 'l' for left, 'r' for right.
                 xtitleplace   = 'c',

                 # Coordinates of title; if empty, guess (you can always
                 # adjust final placement with -xtitleshift).
                 xtitlecoord   = '',          

                 # Use this to adjust title place left/right, up/down.
                 xtitleshift   = [0,0],

                 # How much (in degrees) to rotate the title.
                 xtitlerotate  = 0,

                 # How to anchor text; empty means best guess.
                 xtitleanchor  = '',

                 # If not-empty, color behind title.
                 xtitlebgcolor = '',          

                 # Same as with xtitle, but for ytitle.
                 ytitle        = '',          

                 # Same as with xtitle, but for ytitle.
                 ytitlefont    = 'default',   

                 # Same as with xtitle, but for ytitle.
                 ytitlesize    = 10,          

                 # Same as with xtitle, but for ytitle.
                 ytitlecolor   = 'black',     

                 # Same as with xtitle, but for ytitle.
                 ytitleplace   = 'c',         

                 # Same as with xtitle, but for ytitle.
                 ytitlecoord   = '',          

                 # Same as with xtitle, but for ytitle.
                 ytitleshift   = [0,0],       

                 # Same as with xtitle, but for ytitle (default is different).
                 ytitlerotate  = 90.0,        

                 # Same as with xtitle, but for ytitle.
                 ytitleanchor  = '',          

                 # Same as with xtitle, but for ytitle.
                 ytitlebgcolor = '',          

                 # Main title of the graph.
                 title         = '',          

                 # Same as with xtitle, but for main title.
                 titlefont     = 'default',   

                 # Same as with xtitle, but for main title.
                 titlesize     = 10.0,        

                 # Same as with xtitle, but for main title.
                 titlecolor    = 'black',     

                 # Same as with xtitle, but for main title.
                 titleplace    = 'c',         

                 # Same as with xtitle, but for main title.
                 titleshift    = [0,0],       

                 # Same as with xtitle, but for main title.
                 titlerotate   = 0,           

                 # Same as with xtitle, but for main title.
                 titleanchor   = '',          

                 # Same as with xtitle, but for main title.
                 titlebgcolor  = '',          
                 ):
        assert(drawable != '')

        values = {} # empty dict
        values['xrange,min'] = drawable.virtualmin('x')
        values['xrange,max'] = drawable.virtualmax('x')
        values['yrange,min'] = drawable.virtualmin('y')
        values['yrange,max'] = drawable.virtualmax('y')

        # figure out where axes will go
        if xaxisposition != '':
            values['xaxis,ypos'] = xaxisposition
        else:
            values['xaxis,ypos'] = values['yrange,min']

        if yaxisposition != '':
            values['yaxis,xpos'] = yaxisposition
        else:
            values['yaxis,xpos'] = values['xrange,min']

        # find out ranges of each axis
        if xaxisrange != '':
            assert(len(xaxisrange) == 2)
            values['xaxis,min'] = xaxisrange[0]
            values['xaxis,max'] = xaxisrange[1]
        else:
            values['xaxis,min'] = values['xrange,min']
            values['xaxis,max'] = values['xrange,max']

        if yaxisrange != '':
            assert(len(yaxisrange) == 2)
            values['yaxis,min'] = yaxisrange[0]
            values['yaxis,max'] = yaxisrange[1]
        else:
            values['yaxis,min'] = values['yrange,min']
            values['yaxis,max'] = values['yrange,max']

        # translate each of these values into points
        tvalues = {}
        for v in ['xaxis,min', 'xaxis,max', 'xrange,min', 'xrange,max',
                  'yaxis,xpos']:
            tvalues[v] = drawable.translate('x', values[v])
        for v in ['yaxis,min', 'yaxis,max', 'yrange,min', 'yrange,max',
                  'xaxis,ypos']:
            tvalues[v] = drawable.translate('y', values[v])

        # adjust for linewidths
        half = float(linewidth) / 2.0

        assert(style == 'x' or style == 'y' or style == 'xy' or style == 'box')

        assert(drawable != '')
        canvas = drawable.canvas

        if doaxis == True:
            if style == 'x' or style == 'xy':
                canvas.line(coord=[[tvalues['xaxis,min']-half,
                                    tvalues['xaxis,ypos']],
                                   [tvalues['xaxis,max']+half,
                                    tvalues['xaxis,ypos']]],
                            linecolor=linecolor, linewidth=linewidth,
                            linedash=linedash)
            if style == 'y' or style == 'xy':
                canvas.line(coord=[[tvalues['yaxis,xpos'],
                                    tvalues['yaxis,min']-half],
                                   [tvalues['yaxis,xpos'],
                                    tvalues['yaxis,max']+half]],
                            linecolor=linecolor, linewidth=linewidth,
                            linedash=linedash)

            if style == 'box':
                canvas.line(coord=[[tvalues['xaxis,min']-half,
                                    tvalues['yrange,min']],
                                   [tvalues['xaxis,max']+half,
                                    tvalues['yrange,min']]],
                            linecolor=linecolor, linewidth=linewidth,
                            linedash=linedash)
                canvas.line(coord=[[tvalues['xrange,min'],
                                    tvalues['yaxis,min']-half],
                                   [tvalues['xrange,min'],
                                    tvalues['yaxis,max']+half]],
                            linecolor=linecolor, linewidth=linewidth,
                            linedash=linedash)
                canvas.line(coord=[[tvalues['xaxis,min']-half,
                                    tvalues['yrange,max']],
                                   [tvalues['xaxis,max']+half,
                                    tvalues['yrange,max']]],
                            linecolor=linecolor, linewidth=linewidth,
                            linedash=linedash)
                canvas.line(coord=[[tvalues['xrange,max'],
                                    tvalues['yaxis,min']-half],
                                   [tvalues['xrange,max'],
                                    tvalues['yaxis,max']+half]],
                            linecolor=linecolor, linewidth=linewidth,
                            linedash=linedash)

        # unpack the (complex) args and put useful things into labels and
        # values arrays
        xlabels = []
        ylabels = []
        self.__unpackargs(drawable, axis='x', values=values, labels=xlabels,
                          manual=xmanual, auto=xauto,
                          labelformat=xlabelformat, labeltimes=xlabeltimes)
        self.__unpackargs(drawable, axis='y', values=values, labels=ylabels,
                          manual=ymanual, auto=yauto,
                          labelformat=ylabelformat, labeltimes=ylabeltimes)

        if domajortics == True:
            if doxmajortics and (style == 'x' or style == 'xy'):
                self.__maketics(drawable=drawable, axis='x',
                                axispos=tvalues['xaxis,ypos'], labels=xlabels,
                                ticstyle=ticstyle, ticsize=ticmajorsize,
                                linecolor=linecolor, linewidth=linewidth)
            if doymajortics and (style == 'y' or style == 'xy'):
                self.__maketics(drawable=drawable, axis='y',
                                axispos=tvalues['yaxis,xpos'], labels=ylabels,
                                ticstyle=ticstyle, ticsize=ticmajorsize,
                                linecolor=linecolor, linewidth=linewidth)
            if style == 'box':
                if doxmajortics:
                    self.__maketics(drawable=drawable, axis='x',
                                    axispos=tvalues['yaxis,min'],
                                    labels=xlabels, ticstyle=ticstyle,
                                    ticsize=ticmajorsize, linecolor=linecolor,
                                    linewidth=linewidth)
                    self.__maketics(drawable=drawable, axis='x',
                                    axispos=tvalues['yaxis,max'],
                                    labels=xlabels,
                                    ticstyle=self.__toggle(ticstyle),
                                    ticsize=ticmajorsize,
                                    linecolor=linecolor, linewidth=linewidth)
                if doymajortics:
                    self.__maketics(drawable=drawable, axis='y',
                                    axispos=tvalues['xaxis,min'],
                                    labels=ylabels, ticstyle=ticstyle,
                                    ticsize=ticmajorsize, linecolor=linecolor,
                                    linewidth=linewidth)
                    self.__maketics(drawable=drawable, axis='y',
                                    axispos=tvalues['xaxis,max'],
                                    labels=ylabels,
                                    ticstyle=self.__toggle(ticstyle),
                                    ticsize=ticmajorsize,
                                    linecolor=linecolor, linewidth=linewidth)
                
        if dolabels == True:
            if (style == 'x' or style == 'xy' or style == 'box') and \
                   doxlabels == True:
                self.__makelabels(drawable=drawable, values=values, 
                                  axis='x', axispos=tvalues['xaxis,ypos'],
                                  labels=xlabels, labelstyle=labelstyle,
                                  ticstyle=ticstyle, ticmajorsize=ticmajorsize,
                                  font=xlabelfont, fontsize=xlabelfontsize,
                                  fontcolor=xlabelfontcolor,
                                  labelanchor=xlabelanchor,
                                  labelrotate=xlabelrotate,
                                  labelshift=xlabelshift,
                                  labelbgcolor=xlabelbgcolor)
            if (style == 'y' or style == 'xy' or style == 'box') and \
                   doylabels == True:
                self.__makelabels(drawable=drawable, values=values,
                                  axis='y', axispos=tvalues['yaxis,xpos'],
                                  labels=ylabels, labelstyle=labelstyle,
                                  ticstyle=ticstyle, ticmajorsize=ticmajorsize,
                                  font=ylabelfont, fontsize=ylabelfontsize,
                                  fontcolor=ylabelfontcolor,
                                  labelanchor=ylabelanchor,
                                  labelrotate=ylabelrotate,
                                  labelshift=ylabelshift,
                                  labelbgcolor=ylabelbgcolor)

        self.__maketitle(drawable=drawable, values=values, tvalues=tvalues,
                         # label info ...
                         dolabels=dolabels, doxlabels=doxlabels,
                         doylabels=doylabels, labelstyle=labelstyle,
                         # describing title...
                         title=title, titleshift=titleshift,
                         titlefont=titlefont, titlecolor=titlecolor,
                         titlerotate=titlerotate, titlesize=titlesize,
                         titlebgcolor=titlebgcolor, titleanchor=titleanchor,
                         titleplace=titleplace,
                         # describing xtitle...
                         xtitle=xtitle, xtitleshift=xtitleshift,
                         xtitlefont=xtitlefont, xtitlecolor=xtitlecolor,
                         xtitlerotate=xtitlerotate, xtitlesize=xtitlesize,
                         xtitlebgcolor=xtitlebgcolor, xtitleanchor=xtitleanchor,
                         xtitleplace=xtitleplace,
                         # describing ytitle...
                         ytitle=ytitle, ytitleshift=ytitleshift,
                         ytitlefont=ytitlefont, ytitlecolor=ytitlecolor,
                         ytitlerotate=ytitlerotate, ytitlesize=ytitlesize,
                         ytitlebgcolor=ytitlebgcolor, ytitleanchor=ytitleanchor,
                         ytitleplace=ytitleplace)

        # minortics
        if dominortics == True:
            nxlabels = []
            nylabels = []
            self.__makeminorlabels(nxlabels, xlabels, xminorticcnt)
            self.__makeminorlabels(nylabels, ylabels, yminorticcnt)
            
            if doxminortics and (style == 'x' or style == 'xy'):
                self.__maketics(drawable=drawable, axis='x',
                                axispos=tvalues['xaxis,ypos'], labels=nxlabels,
                                ticstyle=ticstyle, ticsize=ticminorsize,
                                linecolor=linecolor, linewidth=linewidth)
            if doyminortics and (style == 'y' or style == 'xy'):
                self.__maketics(drawable=drawable, axis='y',
                                axispos=tvalues['yaxis,xpos'], labels=nylabels,
                                ticstyle=ticstyle, ticsize=ticminorsize,
                                linecolor=linecolor, linewidth=linewidth)
            if style == 'box':
                if doxminortics:
                    self.__maketics(drawable=drawable, axis='x',
                                    axispos=tvalues['yaxis,min'],
                                    labels=nxlabels, ticstyle=ticstyle,
                                    ticsize=ticminorsize, linecolor=linecolor,
                                    linewidth=linewidth)
                    self.__maketics(drawable=drawable, axis='x',
                                    axispos=tvalues['yaxis,max'],
                                    labels=nxlabels,
                                    ticstyle=self.__toggle(ticstyle),
                                    ticsize=ticminorsize, linecolor=linecolor,
                                    linewidth=linewidth)
                if doyminortics:
                    self.__maketics(drawable=drawable, axis='y',
                                    axispos=tvalues['xaxis,min'],
                                    labels=nylabels, ticstyle=ticstyle,
                                    ticsize=ticminorsize, linecolor=linecolor,
                                    linewidth=linewidth)
                    self.__maketics(drawable=drawable, axis='y',
                                    axispos=tvalues['xaxis,max'],
                                    labels=nylabels,
                                    ticstyle=self.__toggle(ticstyle),
                                    ticsize=ticminorsize, linecolor=linecolor,
                                    linewidth=linewidth)
        return
    #END: __init__()

    def __recordlabel(self, drawable, values, axis, x, y, label,
                      font, fontsize, anchor, rotate):
        # height and width
        height = fontsize
        canvas = drawable.canvas
        width  = canvas.get_string_width(font, fontsize, label)

        # get anchors
        a = anchor.split(',')
        if len(a) == 2:
            xanchor = a[0]
            yanchor = a[1]
        elif len(a) == 1:
            xanchor = a[0]
            yanchor = 'l'
        else:
            abort('rbad anchor: '+ anchor)

        # XXX deal with rotation XXX
    
        # now, find bounding box 
        if xanchor == 'l':
            xlo = x
        elif xanchor == 'c':
            xlo = x - (width/2.0)
        elif xanchor == 'r':
            xlo = x - width 

        if yanchor == 'l':
            ylo = y
        elif yanchor == 'c':
            ylo = y - (height/2.0)
        elif yanchor == 'h':
            ylo = y - height 

        xhi = xlo + width
        yhi = ylo + height

        if (('labelbox,'+axis+',xlo' in values) == False) or \
               (xlo < values['labelbox,'+axis+',xlo']):
            values['labelbox,'+axis+',xlo'] = xlo
        if (('labelbox,'+axis+',ylo' in values) == False) or \
               (ylo < values['labelbox,'+axis+',ylo']):
            values['labelbox,'+axis+',ylo'] = ylo
        if (('labelbox,'+axis+',xhi' in values) == False) or \
               (xhi > values['labelbox,'+axis+',xhi']):
            values['labelbox,'+axis+',xhi'] = xhi
        if (('labelbox,'+axis+',yhi' in values) == False) or \
               (yhi > values['labelbox,'+axis+',yhi']):
            values['labelbox,'+axis+',yhi'] = yhi
        return
    #END: __recordlabel()

    def __makelabels(self,
                     drawable,
                     values,
                     axis,
                     axispos,
                     labels,
                     labelstyle,
                     ticstyle,
                     ticmajorsize,
                     font,
                     fontsize,
                     fontcolor,
                     labelanchor,
                     labelrotate,
                     labelshift,
                     labelbgcolor,
                     ):
        # how much space between fonts and tics, basically
        offset = 3.0 

        # set fixpos to the place where labels should be drawn
        #   for yaxis, this is the x position of the labels
        #   for xaxis, this is the y position of the labels
        # fixpos thus does not change and is used to draw each of the labels
        if labelstyle == 'out':
            if axis == 'x':
                anchor = 'c,h'
            else:
                anchor = 'r,c'

            if ticstyle == 'in':
                fixpos = axispos - offset
            elif ticstyle == 'out':
                fixpos = axispos - ticmajorsize - offset 
            elif ticstyle == 'centered':
                fixpos = axispos - (ticmajorsize/2.0) - offset
            else:
                abort('bad ticstyle: ' + ticstyle)

        if labelstyle == 'in':
            if axis == 'x':
                anchor = 'c,l'
            else:
                anchor = 'l,c'

            if ticstyle == 'in':
                fixpos = axispos + ticmajorsize + offset
            elif ticstyle == 'out':
                fixpos = axispos + offset
            elif ticstyle == 'centered':
                fixpos = axispos + (ticmajorsize/2.0) + offset
            else:
                abort('bad ticstyle: ' + ticstyle)

        # allow intelligent override, otherwise provide solid guess as to
        # label placement
        if labelanchor != '':
            anchor = labelanchor

        assert(drawable != '')
        canvas = drawable.canvas

        # draw the labels
        for i in range(0, len(labels)):
            label  = labels[i][0]
            value  = labels[i][1]
            movpos = drawable.translate(axis, value)
            if axis == 'x':
                x = movpos + labelshift[0]
                y = fixpos + labelshift[1]
                canvas.text(coord=[x,y], text=label, font=font, size=fontsize,
                            color=fontcolor, anchor=anchor, rotate=labelrotate,
                            bgcolor=labelbgcolor)
            elif axis == 'y':
                x = fixpos + labelshift[0]
                y = movpos + labelshift[1]
                canvas.text(coord=[x,y], text=label, font=font, size=fontsize,
                            color=fontcolor, anchor=anchor, rotate=labelrotate,
                            bgcolor=labelbgcolor)
            else:
                abort('bad axis: ' + axis)
            # record where text is s.t. later title pos are properly placed 
            self.__recordlabel(drawable=drawable, values=values, axis=axis, x=x,
                               y=y, label=label, font=font, fontsize=fontsize,
                               anchor=anchor, rotate=labelrotate)
        return

    def __maketics(self,
                   drawable,
                   axis,
                   axispos,
                   labels,
                   ticstyle,
                   ticsize,
                   linecolor,
                   linewidth):
        if ticstyle == 'in':
            hipos = axispos + ticsize
            lopos = axispos
        elif ticstyle == 'out':
            hipos = axispos
            lopos = axispos - ticsize
        elif ticstyle == 'centered':
            hipos = axispos + (ticsize/2.0)
            lopos = axispos - (ticsize/2.0)
        else:
            abort('bad tic style: ' + ticstyle)

        canvas = drawable.canvas

        # draw the tic marks AT EACH LABEL in labels array
        for i in range(0, len(labels)):
            label  = labels[i][0]
            value  = labels[i][1]
            tvalue = drawable.translate(axis, value)
            if axis == 'x':
                canvas.line(coord=[[tvalue,lopos],[tvalue,hipos]],
                            linecolor=linecolor, linewidth=linewidth)
            elif axis == 'y':
                canvas.line(coord=[[lopos,tvalue],[hipos,tvalue]],
                            linecolor=linecolor, linewidth=linewidth)
        return
    # END: maketics()
    
    def __findmajorstep(self,
                        drawable,
                        axis,
                        vmin,
                        vmax):
        # XXX 3.5 is pretty random
        ticsperinch = 3.5 
        width = drawable.getsize(axis) / 72.0
        tics  = width * ticsperinch
        step  = 1 + int((vmax - vmin) / tics)
        return step
    # END: findmajorstep()

    def __unpackargs(self,
                     drawable,
                     axis,
                     values,
                     labels,
                     manual,
                     auto,
                     labelformat,
                     labeltimes, 
                     ):
        assert(axis == 'x' or axis == 'y')
        rangemin = values[axis+'range,min']
        rangemax = values[axis+'range,max'] 

        # now, unpack label and tic info
        if manual != '':
            # if manual is not empty, use it (override auto)
            for m in manual:
                if labelformat == '':
                    labelformat = '%s'
                assert(len(m) == 2)
                name     = m[0]
                location = m[1]
                labels.append([labelformat % name, location])
        else:
            assert(len(auto) == 3)
            if auto[0] == '':
                values[axis+',min'] = rangemin
            else:
                values[axis+',min'] = auto[0]

            if auto[0] == '':
                values[axis+',max'] = rangemax
            else:
                values[axis+',max'] = auto[1]

            if auto[2] == '':
                # This assumes that rangemin, max are linear values, whereas
                # they MIGHT NOT BE. More proper to: take virtual values, map
                # them to linear, figure out what to do then 
                # values[axis+',step'] =
                #   int((float(rangemax) - float(rangemin)) / 10.0)
                values[axis+',step'] = self.__findmajorstep(drawable=drawable,
                                                            axis=axis,
                                                            vmin=rangemin,
                                                            vmax=rangemax)
            else:
                values[axis+',step'] = auto[2]

            if values[axis+',step'] <= 0:
                values[axis+',step'] = 1

            # now, set the format properly, if needed
            if labelformat == '':
                if drawable.getscaletype(axis) == 'category':
                    labelformat = '%s'
                else:
                    notInt = 0
                    for i in [',min', ',max', ',step']:
                        if values[axis+i] != int(values[axis+i]):
                            notInt = notInt + 1
                    if notInt > 0:
                        labelformat = '%.1f'
                    else:
                        labelformat = '%d'

            # now, fill in labels array with positions of each label
            init = values[axis+',min']
            assert(values[axis+',min'] < values[axis+',max'])
            assert(values[axis+',step'] > 0)
            while init <= values[axis+',max']:
                if labeltimes != 1:
                    labels.append([labelformat % (init * labeltimes), init])
                else:
                    labels.append([labelformat % init, init])
                init = init + values[axis+',step']
        return
    # END: __unpackargs()

    def __maketitle(self, drawable, values, tvalues, dolabels, doxlabels,
                    doylabels, title, titleshift, titlefont, titlecolor,
                    titlerotate, titlesize, titlebgcolor, titleanchor,
                    titleplace, xtitle, xtitleshift, xtitlefont, xtitlecolor,
                    xtitlerotate, xtitlesize, xtitlebgcolor, xtitleanchor,
                    xtitleplace, ytitle, ytitleshift, ytitlefont, ytitlecolor,
                    ytitlerotate, ytitlesize, ytitlebgcolor, ytitleanchor,
                    ytitleplace, labelstyle):                    
        # some space between titles and the nearest text to them;
        # 3 is randomly chosen
        offset = 3.0
        canvas = drawable.canvas

        if title != '':
            values['title,y'] = tvalues['yrange,max'] + (2.5 * offset)
            if titleplace == 'c':
                values['title,x']      = (tvalues['xrange,min'] + \
                                          tvalues['xrange,max']) / 2.0
                values['title,anchor'] = 'c,l'
            elif titleplace == 'l':
                values['title,x']      = tvalues['xrange,min'] + offset
                values['title,anchor'] = 'l,l'
            elif titleplace == 'r':
                values['title,x']      = tvalues['xrange,max'] - offset
                values['title,anchor'] = 'r,l'
            else:
                abort('bad titleanchor: Must be c, l, or r')

            # allow user override of this option, of course
            if titleanchor != '':
                values['title,anchor'] = titleanchor
        # END: if title != ''
                
        if ytitle != '':
            if labelstyle == 'in':
                values['ytitle,x']  = tvalues['yaxis,xpos'] + offset
                yanchor             = 'h'
            elif labelstyle == 'out':
                values['ytitle,x']  = tvalues['yaxis,xpos'] - offset
                yanchor             = 'l'
            else:
                abort('bad labelstyle')
        
            if ytitleplace == 'c':
                values['ytitle,y']  = (tvalues['yrange,max'] + \
                                       tvalues['yrange,min']) / 2.0
                xanchor             = 'c'
            elif ytitleplace == 'l':
                values['ytitle,y']  = tvalues['yrange,min'] + offset
                xanchor             = 'l'
            elif ytitleplace == 'u':
                values['ytitle,y']  = tvalues['yrange,max'] - offset
                xanchor             = 'r'
            else:
                abort('Bad titleanchor: Must be c, l, or u')

            # allow user override of this option, of course
            if ytitleanchor != '':
                values['ytitle,anchor'] = ytitleanchor
            else:
                values['ytitle,anchor'] = xanchor + ',' + yanchor

            # try to move ytitle based on labelbox(y,*)
            if dolabels == True:
                if doylabels == True:
                    if labelstyle == 'out':
                        if values['ytitle,x'] >= values['labelbox,y,xlo']:
                            values['ytitle,x'] = values['labelbox,y,xlo'] - \
                                                 offset
                    if labelstyle == 'in':
                        if values['ytitle,x'] <= values['labelbox,y,xhi']:
                            values['ytitle,x'] = values['labelbox,y,xhi'] + \
                                                 offset
        # END: if ytitle != ''

        if xtitle != '':
            if labelstyle == 'in':
                values['xtitle,y']   = tvalues['xaxis,ypos'] + offset
                yanchor              = 'l'
            elif labelstyle == 'out':
                values['xtitle,y']   = tvalues['xaxis,ypos'] - offset
                yanchor              = 'h'
            else:
                abort('bad labelstyle')

            if xtitleplace == 'c':
                values['xtitle,x']   = (tvalues['xrange,min'] + \
                                        tvalues['xrange,max']) / 2.0
                xanchor              = 'c'
            elif xtitleplace == 'l':
                values['xtitle,x']   = tvalues['xrange,min'] + offset
                xanchor              = 'l'
            elif xtitleplace == 'r':
                values['xtitle,x']   = tvalues['xrange,max'] - offset
                xanchor              = 'r'
            else:
                abort('Bad titleanchor: Must be c, l, or r')

            # allow user override of this option, of course
            if xtitleanchor != '':
                values['xtitle,anchor'] = xtitleanchor
            else:
                values['xtitle,anchor'] = xanchor + ',' + yanchor

            # move xtitle if there are xlabels in the way
            if dolabels == True:
                if doxlabels == True:
                    if values['xtitle,y'] >= values['labelbox,x,ylo']:
                        values['xtitle,y'] = values['labelbox,x,ylo'] - offset
        # END: if xtitle != ''

        # finish up
        if title != '':
            canvas.text(coord=[titleshift[0]+values['title,x'],
                               titleshift[1]+values['title,y']],
                        text=title, font=titlefont, size=titlesize,
                        color=titlecolor, anchor=values['title,anchor'],
                        bgcolor=titlebgcolor, rotate=titlerotate)

        if xtitle != '':
            canvas.text(coord=[xtitleshift[0]+values['xtitle,x'],
                               xtitleshift[1]+values['xtitle,y']],
                        text=xtitle, font=xtitlefont, size=xtitlesize,
                        color=xtitlecolor, anchor=values['xtitle,anchor'],
                        bgcolor=xtitlebgcolor, rotate=xtitlerotate)

        if ytitle != '':
            canvas.text(coord=[ytitleshift[0]+values['ytitle,x'],
                               ytitleshift[1]+values['ytitle,y']],
                        text=ytitle, font=ytitlefont, size=ytitlesize,
                        color=ytitlecolor, anchor=values['ytitle,anchor'],
                        bgcolor=ytitlebgcolor, rotate=ytitlerotate)
    # END: __maketitle()

    def __toggle(self,
                 style):
        if style == 'in':
            return 'out'
        elif style == 'out':
            return 'in'
        return 'centered'

    def __makeminorlabels(self, nlabels, labels, minorticcnt):
        for i in range(0, len(labels) - 1):
            curr   = labels[i]
            next   = labels[i+1]
            clabel = curr[0]
            cvalue = curr[1]
            nlabel = next[0]
            nvalue = next[1]
            diff   = (nvalue - cvalue) / (minorticcnt + 1.0)

            nlabels.append(curr)
            for j in range(0, minorticcnt):
                cvalue = cvalue + diff
                nlabels.append(['', cvalue])
        return
    # END: __makeminorlabels
#END: class axis

#
# --class-- grid
#
# Just a simple way to draw grids onto graphs. While we generally don't like
# grids, some people do.
#
class grid:
    def __init__(self,
                 # The relevant drawable upon which to place this grid.
                 drawable  = '',

                 # The color of grid lines.
                 linecolor = 'black',

                 # The width of grid lines.
                 linewidth = 0.5,          

                 # Make grid lines dashed as per usual patterns. Examples:
                 # 0 for no dashes, [2,2] for length 2 lines with length 2
                 # spaces, etc.
                 linedash  = 0,
                 
                 # Specify false to turn off grid in x direction
                 # (False means no vertical lines).
                 x         = True,

                 # Specify false to turn off grid in y direction
                 # (False means no horizontal lines).
                 y         = True,

                 # Empty means whole range, otherwise a [y1,y2] as beginning
                 # and end of the range to draw vertical lines upon.
                 xrange    = '',

                 # How much space to skip between each x. grid line. 
                 # If log scale, this will be used in a multiplicative manner.
                 xstep     = '',

                 # Empty means whole range, otherwise a [x1,x2] as beginning
                 # and end of the range to draw horizontal lines upon.
                 yrange    = '',

                 # How much space to skip between each y grid line.
                 # if log scale, this will be used in a multiplicative manner.
                 ystep     = '',           
                 ):

        if x == True:
            self.__dogrid(drawable=drawable, axis='x', step=xstep,
                          range=xrange, linecolor=linecolor,
                          linewidth=linewidth, linedash=linedash)
        if y == True:
            self.__dogrid(drawable=drawable, axis='y', step=ystep,
                          range=yrange, linecolor=linecolor,
                          linewidth=linewidth, linedash=linedash)
    # END __init__

    def __dogrid(self,
                 drawable,
                 axis,
                 step,
                 range,
                 linecolor, linewidth, linedash):
        assert(step != '')
        if axis == 'x':
            otheraxis = 'y'
        elif axis == 'y':
            otheraxis = 'x'

        urange = []
        if range == '':
            # THIS SHOULD BE TRANSLATABLE
            urange.append(drawable.virtualmin(axis))
            urange.append(drawable.virtualmax(axis))
        else:
            urange = range
            assert(len(urange) == 2)

        # THIS SHOULD BE TRANSLATABLE
        othermin = drawable.virtualmin(otheraxis)
        othermax = drawable.virtualmax(otheraxis)

        # iterate over the range
        canvas = drawable.canvas
        for v in drawable.rangeiterator(axis, urange[0], urange[1], step):
            if axis == 'x':
                canvas.line(coord=drawable.map([[v,othermin],[v,othermax]]),
                            linecolor=linecolor, linewidth=linewidth,
                            linedash=linedash)
            if axis == 'y':
                canvas.line(coord=drawable.map([[othermin,v],[othermax,v]]),
                            linecolor=linecolor, linewidth=linewidth,
                            linedash=linedash)
    # END __dogrid()
    
# END: class grid

#
# --class-- legend
#
# Minimal support for legends is provided. Initialize it first 
# (e.g., L = Legend()). Then pass 'L' and other info into plotters.
# (e.g., legend=L, legendtext='foo'). Finally, call legend.draw()
# to make the legend on the plot.
# 
class legend:
    def __init__(self,
                 ):
        # 'info' field will track each picture and text in the legend
        # All the work is done later - when legend is drawn.
        self.info = []
    # END: __init__

    # 
    # --method-- draw
    # 
    # Use this to draw a legend given the current entries in the legend.
    # 
    def draw(self,
             # Legend draws directly onto canvas.
             canvas      = '',        

             # Where to place the legend (lower left point).
             # Note these are canvas coordinates; if you want to use a
             # drawable's coordinated (e.g., drawable 'd'), call d.map([x,y])
             # and pass the result into 'coord' here for the desired outcome.
             coord       = '',

             # which side to place the text on, right or left?
             style       = 'right',

             # width of the picture to be drawn in the legend
             width       = 10.0,

             # height of the picture to be drawn in the legend
             height      = 10.0,

             # number of points to skip when moving to next legend entry
             vskip       = 3.0,

             # space between pictures and text
             hspace      = 4.0,

             # go downward from starting spot when building the legend;
             # false goes upward
             down        = True,

             # if non-empty, how many rows of legend to print(before)
             # skipping to a new column
             skipnext    = '',

             # how much to move over if the 'skipnext' option is used to
             # start the next column
             skipspace   = 25.0,

             # which type face to use
             font        = 'default',

             # size of font of legend, and color
             fontsize    = 10,        
             fontcolor   = 'black',

             # can specify a specific legend order ...
             order       = [],
             ):

        if canvas == '':
            print('error: must specify canvas when drawing legend', )
            print('(legend not drawn as result)')
            return
        assert(len(coord) == 2)
        x = coord[0]
        y = coord[1]
        w = width
        h = height

        if w < h:
            minval = w
        else:
            minval = h

        overcounter = 0
        for i in range(0, len(self.info)):
            if(len(order) > 0):
                i = order[i]

            if style == 'left':
                cx = x + hspace + (w/2.0)
                tx = x
            elif style == 'right':
                cx = x + (w/2.0)
                tx = x + w + hspace
            else:
                abort('bad style: ', style)

            # make replacements for coordinates in legend pictures
            legend = self.info[i]
            text   = legend[0]
            pic    = legend[1]

            mapped = pic.substitute(__Xx=cx, __Yy=y, __Ww=w, __Hh=h,
                                    __Mm=minval, __W2=(w/2.0), __H2=(h/2.0),
                                    __M2=(minval/2.0), __Xmm=(cx-(minval/2.0)),
                                    __Xpm=cx+(minval/2.0),
                                    __Ymm=(y-(minval/2.0)),
                                    __Ypm=(y+(minval/2.0)), __Xmw=cx-(w/2.0),
                                    __Xpw=(cx+(w/2.0)), __Ymh=(y-(h/2.0)),
                                    __Yph=(y+(h/2.0)))

            if style == 'left':
                canvas.text(coord=[tx,y], anchor='r,c', text=text, font=font,
                            color=fontcolor, size=fontsize)
                eval(mapped)
            elif style == 'right':
                for m in mapped.split(';'):
                    eval(m)
                canvas.text(coord=[tx,y], anchor='l,c', text=text, font=font,
                            color=fontcolor, size=fontsize)

            if down == True:
                y = y - height - vskip
            else:
                y = y + height + vskip

            if skipnext != '':
                overcounter = overcounter + 1
                if overcounter >= skipnext:
                    if type(skipspace) == list:
                        x += skipspace.pop(0)
                    else:
                        x = x + skipspace
                    y = coord[1]
                    overcounter = 0
        # END: for i in range...
        return
    # END: draw()

    # 
    # Method used by plotters to add info about a legend to the legend list.
    # If 'entry' is specified, this will add the text (if any) to the existing
    # text in that spot, and also add the picture to the list of pictures to be
    # drawn for this entry. If 'entry' is not specified, simply use the current
    # counter and add this to the end of the list.
    # 
    def add(self,
            # text for the legend
            text    = '',  

            # code to add the picture to the legend: COORDX and COORDY should
            # be used to specify the lower-left point of the picture key;
            # WIDTH and HEIGHT should be used to specify the width and height
            # of the picture
            picture = '',

            # entry number: which legend entry this should be
            # (empty means auto-picked for you).
            entry   = '',   
            ):

        if entry == '':
            self.info.append([text, picture])
        else:
            self.info[entry] = [text, picture]
    # END: add()

#END: class legend
